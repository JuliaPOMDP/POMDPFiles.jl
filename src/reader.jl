const REGEX_FLOATING_POINT = r"[-+]?[0-9]*\.?[0-9]+"

##
# -- Create a type for parsing the reward function 
# -- Deal with large files 

"""
    Read a `.alpha` file as generated by pomdp-solve.
    Works the same was as `read_pomdp` in `POMDPXFile.jl`.

    The `.alpha` file format is recapped here as follows,
    see: http://www.pomdp.org/code/alpha-file-spec.html

    A set of vectors is the representation use for the value function and each
    vector has an action associated with it. The vectors represent the coefficients
    of a hyperplane passing through the origin. The format specified here is what is
    output from the 'pomdp-solve' program and what will be necessary for input to
    the 'pomdp-solve' program with the '-terminal_values' command line option.

    The format is simply:

    A
    V1 V2 V3 ... VN

    A
    V1 V2 V3 ... VN

    ...


    Where `A` is an action number and the `V1` through `VN` are real values
    representing the components of a particular vector that has the associated
    action. The action number is the 0-based index of the action as specificed in
    the input POMDP file. The vector represents the coefficients of a hyperplane
    representing one facet of the piecewise linear and convex value function.
    Note that the length of the lists needs to be equal to the number of states in
    the POMDP.

    To find which action is the "best" for a given set of alpha vectors, the belief
    state probabilities would be used in a dot product against each alpha vectors'
    coefficients. The action associated with the vector with the highest value is
    the best action to take for that belief state given the value function.
"""
function read_alpha(filename::AbstractString)
    lines = open(readlines, filename)

    alpha_vector_line_indeces = Int[]
    vector_length = -1

    for i in eachindex(lines)

        matches = collect((m.match for m = eachmatch(REGEX_FLOATING_POINT, lines[i])))

        if length(matches) > 1
            push!(alpha_vector_line_indeces, i)
            @assert occursin(r"^(\d)*$", lines[i-1]) "previous line must contain an action index"

            if vector_length == -1
                vector_length = length(matches)
            else
                @assert vector_length == length(matches) "vector length is inconsistent. Was $vector_length, is $(length(matches)) on line $i"
            end
        end
    end
    num_alpha_vectors = length(alpha_vector_line_indeces)

    # Initialize the Γ matrix.
    # The α-vectors are the columns
    alpha_vectors = Array{Float64}(undef, vector_length, num_alpha_vectors)

    # Initialize the alpha_actions vector
    # alpha_actions[i] is the index of the action associated with
    # the alpha-vector in the ith column of alpha_vectors
    # Note that these are 0-indexed
    alpha_actions = Array{Int}(undef, num_alpha_vectors)

    for (i,line_index) in enumerate(alpha_vector_line_indeces)
        alpha_actions[i] = parse(Int, lines[line_index-1])

        for (j,match) in enumerate(eachmatch(REGEX_FLOATING_POINT, lines[line_index]))
            alpha_vectors[j,i] = parse(Float64, match.match)
        end
    end

    return alpha_vectors, alpha_actions
end

function read_pomdp(filename::String, output::Symbol = :SFilePOMDP)
    lines = open(readlines, filename) |> remove_comments_and_white_space
    # Reading the preamble of the file
    test_preamble = check_preamble_fields(lines)

    discount, type_reward, actions, states, observations = process_preamble(test_preamble)
    
    ss_dic = Dict{String, Int64}(nn => index for (index, nn) in enumerate(string.(states.names_of_states)))

    # Processing the initial distribution
    regex_init_cond = r"\s*start include\s*:|\s*start exclude\s*:|\s*start\s*:"

    init_state_lines = findall(startswith.(lines, regex_init_cond)) 

    init_state_info = InitialStateParam()

    if !isempty(lines[init_state_lines])
        init_state_info = process_initial_distribution(states.number_of_states, ss_dic, lines[init_state_lines])
    end

    # # Processing transition probability

    sorted_fields = order_of_transition_reward_observation(lines, 1)

    files_transition = []
    files_obs = []
    files_values = []

    # Finding the chunk of the file with the transition, observation, and reward specifications
    for (index, (type_of_matrix, line_number)) in enumerate(sorted_fields)
        if index  < length(sorted_fields)
            range_spec = line_number:(sorted_fields[index+1][2] -1)
            if isequal(type_of_matrix, "T")
                files_transition = lines[range_spec]
            end
            if isequal(type_of_matrix, "O")
                files_obs = lines[range_spec]
            end
            if isequal(type_of_matrix, "R")
                files_values = lines[range_spec]
            end
        else
            range_spec = (line_number:length(lines))
            if isequal(type_of_matrix, "T")
                files_transition = lines[range_spec]
            end
            if isequal(type_of_matrix, "O")
                files_obs = lines[range_spec]
            end
            if isequal(type_of_matrix, "R")
                files_values = lines[range_spec]
            end
        end
    end

    dic_action = Dict(string(nn) => index for (index, nn) in enumerate(names(actions)))
    dic_states = Dict(string(nn) => index for (index, nn) in enumerate(names(states)))
    dic_obs = Dict(string(nn) => index for (index, nn) in enumerate(names(observations)))

    transition_prob = process_transitions(DynamicTransition("T", number(states), number(actions), ["uniform", "identity"]), dic_states, dic_action, dic_states, files_transition)
    obs_prob = process_transitions(ObsTransition("O", number(states), number(actions), number(observations), ["uniform"]), dic_states, dic_action, dic_obs, files_obs)
    # values_matrix = process_reward_function(number(states), number(actions), number(observations), dic_states, dic_action, dic_obs, files_values)
    values_matrix = _process_transitions(ValueTransition("R", number(states), number(actions), number(observations), []), dic_states, dic_action, dic_obs, files_values)

    pomdp_struc = FilePOMDP(number(states), number(actions), number(observations), init_state_info, discount[1], transition_prob, obs_prob, values_matrix)

    if output == :FilePOMDP
        return pomdp_struc
    elseif output == :SFilePOMDP
        return SFilePOMDP(dic_states, dic_action, dic_obs, pomdp_struc)
    else
        error("Output type invalid")
    end
end

################ Auxiliary functions ##################
function test_if_probability(prob::Vector{Float64})
    between_0_1 = all(x -> 0 <= x <= 1, prob)
    return (between_0_1 && isapprox(sum(prob), 1; rtol=1e-3)) ? true : false
end

function remove_comments_and_white_space(file::AbstractVector{String})
    processed_file = []

    for line in file
        without_comments = replace(line, r"#.*" => "") |> strip

        if !isempty(without_comments)
            push!(processed_file, without_comments)
        end
    end

    admissible_strings = ["discount", "values", "states", "actions", "observations", "start", "start include", "start exclude"]

    for (index, line) in enumerate(processed_file)
        tt_line = string(line)
        before_colon = get_before_colon(tt_line) |> strip
        after_colon = get_after_colon(tt_line) |> strip

        # This part of the code is joining in the preamble to facilitate parsing. Otherwise we would have to add code to deal with the case where the parameters are passed in the next line
        if (before_colon in admissible_strings) && isempty(after_colon)
            processed_file[index] = before_colon * ":" * processed_file[index + 1]
            processed_file[index+1] = ""
        end
    end

    return Vector{String}(filter(x -> !isempty(x), processed_file))
end

function get_before_colon(line::String)
    regex_before_colon = r"([^:]*):"

    search_pattern = match(regex_before_colon, line)
    
    return !isnothing(search_pattern) ? replace(search_pattern.match, r":+" => "") : "none-found"
end

function get_after_colon(line::String)
    regex_after_colon = r":(.)*$"

    search_pattern = match(regex_after_colon, line)

    if !isnothing(search_pattern)
        return replace(search_pattern.match, r":+" => "")
    else
        return "none-found"
    end
end

function convert_to_data_structure(field::String, preamble_config::Dict{String,String}) 
    entry = preamble_config[field]
    entry = replace(entry, r"\"+" => "")
    
    test_entry = tryparse(Int64, entry)

    if typeof(test_entry) == Int64
        param = test_entry
    else
        param = split(entry)
    end

    return param 
end

function order_of_transition_reward_observation(file_lines::Vector{String}, start_line::Int64) 
    key_field = ["O", "T", "R"]
    regex_fields = Vector{String}()

    [push!(regex_fields, "\\s*$field\\s*:") for field in key_field]

    indices = map(x-> findfirst(startswith.(file_lines, Regex(x))), regex_fields)

    dict_scanning = Dict(field => indices[ii] for (ii, field) in enumerate(key_field)) 
    sorted_fields = sort(collect(pairs(dict_scanning)), by=x->x[2])

    return sorted_fields
end

######### Auxiliary functions -- PREAMBLE ###############

function check_preamble_fields(file_lines::Vector{String})
    key_fields = ["discount", "values", "states", "actions", "observations"]
   
    organized_preamble = Dict{String, String}() 
    field_dict = Dict{String, Int64}()

    for field in key_fields
        reg_expr = Regex("\\s*$(field)\\s*:")
        index = findfirst(startswith.(file_lines, reg_expr))

        if !isnothing(index) 
            field_dict[field] = index
        else
            error("Missing field $(field) in the file")
        end
    end

    sorted_fields = sort(collect(field_dict), by = x -> x[2]) # sorting is necessary to deal with the case in which the parameters are specified in several lines

    for (counter, (field, index_in_file)) in enumerate(sorted_fields) # necessary to deal with in-between specifications
       
        if counter < length(sorted_fields)
            if sorted_fields[counter+1][2] - index_in_file == 1
                temp_match = get_after_colon(file_lines[index_in_file]) |> strip
            else
                range_spec = index_in_file:(sorted_fields[counter+1][2]-1)
                temp_match = join(file_lines[range_spec], " ") |> get_after_colon |> strip 
            end
        else
            other_fields = ["T", "O", "R", "start", "start include", "start exclude"]
            regex_other = ""

            # Construction regex to field other fields
            for (index, field) in enumerate(other_fields)
                regex_other *= "\\s*$(field)\\s*:"
                if index < length(other_fields)
                    regex_other *= "|"
                end
            end
            next_indices = findfirst(startswith.(file_lines, Regex(regex_other)))

            if isnothing(next_indices)
                error("Error while parsing the preamble. It seems the information about the transitions is missing from the file.")
            else
                if next_indices - index_in_file == 1 
                    temp_match = get_after_colon(file_lines[index_in_file]) |> strip
                else
                    range_spec = index_in_file:(next_indices-1)

                    temp_match = join(file_lines[range_spec], " ") |> get_after_colon |> strip
                end
            end
        end

        organized_preamble[field] = temp_match 
    end

    return Dict{String, String}(kk => mm for (kk,mm) in organized_preamble) 
end

function process_preamble(preamble_config::Dict{String, String})
    # checking discount syntax => it must be a float number
    entry = preamble_config["discount"]
    test_entry = tryparse(Float64, entry)
    discount_param = [(typeof(test_entry) == Float64) && (0 <= test_entry <= 1) ? test_entry : error("Discount parameter must be a number between zero and one") ]

    # checking value syntax => either "reward" or "cost"
    entry = preamble_config["values"]
    entry = replace(entry, r"[\"+]|[\s+]" => "")
    values_param = [(isequal(entry,"reward")) || (isequal(entry,"cost") || isequal(entry, "rewards") || isequal(entry, "costs")) ? entry : error("Invalid specification for the objective function.")]

    # checking actions syntax => either an integer or a collection of names
    actions_param = convert_to_data_structure("actions", preamble_config) 
    
    # checking states syntax => either an integer or a collection of names
    states_param = convert_to_data_structure("states", preamble_config) 

    # checking observation syntax => either an integer or a collection of names
    observations_param = convert_to_data_structure("observations", preamble_config)


    # IT IS MISSING TO TEST WHERE WE HAVE A VECTOR OF STRINGS HERE
    return discount_param, values_param, ActionsParam(actions_param), StateParam(states_param), ObservationParam(observations_param) 
end

################ Auxiliary functions -- INITIAL DISTRIBUTION ################## 

function _process_initial_distribution_start(state_size::Int64, after_colon::String, name_of_states::Dict{String, Int64})
    aux_var = tryparse(Int64, after_colon)

    if all(map(x -> !isnothing(tryparse(Int64, x)), split(after_colon))) # testing whether is a number
        aux_var = map(x -> parse(Int64, x), split(after_colon))  

        if maximum(aux_var) > state_size
            error("Unable to parse the initial state since initial condition is larger than the size of the state space.")
        end

        value_of_distribution = Diagonal(ones(Float64, state_size))[:,aux_var]
        support_of_distribution = Set{Int64}(aux_var) 

        if length(aux_var) == 1
            return InitialStateParam{Int64}(state_size, "dirac", support_of_distribution, vec(value_of_distribution)) 
        else
            value_of_distribution = sum(value_of_distribution, dims=2) |> vec
            value_of_distribution = value_of_distribution/sum(value_of_distribution)
            return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution) 
        end
        
    elseif all(x -> isa(x, Float64) && (x<=1) && (x>=0) , map(x->tryparse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))) # testing whether initial distirbution is a probability vector
        value_of_distribution =  map(x->parse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))
        support_of_distribution =  Set(findall(x -> x > 0, value_of_distribution))
        return InitialStateParam{Int64}(state_size, "general distribution", support_of_distribution, value_of_distribution) 

    elseif isequal(replace(after_colon, r"[\"+]|[\s+]" => ""), "uniform") # testing initial state is uniform 
        value_of_distribution = (1/state_size)*ones(state_size)
        support_of_distribution = Set{Int64}([i for i in Base.OneTo(state_size)])

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution)

    elseif all(x -> x in keys(name_of_states), split(after_colon)) # where the initial distribution is passed with names
        init_state = map(x -> name_of_states[x], split(after_colon))

        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)
        
        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        # println(split(after_colon))
        error("Invalid syntax for the initial condition.")
    end


end

function _process_initial_distribution_start_include(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})
    init_state = split(after_colon)
    state_size = number(state_initial_param)
    
    if all(x -> tryparse(Int64, x) in 1:state_size, init_state) 
        adding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    elseif all(x -> x in keys(name_of_states), init_state)
        init_state = map(x -> name_of_states[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    else
        error("Unable to parse the start include line.")
    end
end

function _process_initial_distribution_start_exclude(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})
    init_state = split(after_colon)
    state_size = state_initial_param.size_of_states
    
    if all(x -> isa(tryparse(Int64, x), Int64), init_state) 
        excluding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    elseif all(x -> x in keys(name_of_states), init_state)
        init_state = map(x -> name_of_states[x], init_state)
        excluding_set = Set{Int64}(init_state)

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    else
        error("Unable to parse the start exclude line.")
    end
    
    return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
end

function process_initial_distribution(number_of_states::Int64, name_of_states::Dict{String, Int64}, initial_state_ocurrences::Vector{String})
    # According to the grammar this can either be a number, a probability distribution over states, or strings (uniform or states' names)
    initial_state_param = InitialStateParam(number_of_states)
    
    for line in initial_state_ocurrences
        type_init_state = get_before_colon(line)
        param_init = get_after_colon(line) 
       
        if isequal(type_init_state, "start")
            initial_state_param = _process_initial_distribution_start(number_of_states, param_init, name_of_states)

        elseif isequal(type_init_state, "start include")
            initial_state_param = _process_initial_distribution_start_include(initial_state_param, param_init, name_of_states)
            
        elseif isequal(type_init_state, "start exclude")
            initial_state_param = _process_initial_distribution_start_exclude(initial_state_param, param_init, name_of_states)
        else
            error("Unable to parse the initial condition.")
        end
    end

    return initial_state_param
end

################ Auxiliary functions -- TRANSITION PROBABILITY ################## 

abstract type LineParsing end
abstract type ProbTrans end
abstract type TypeOfTransition end

function turn_into_number!(ℓ::LineParsing, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, indices::Vector{Int64})
    # the index parameter serves to select whether or not the entry is allowed to be substituted. This is essential to deal with the wild card
    if !isempty(name_of_states)
        if 3 in indices
            if isnothing(tryparse(Int64, ℓ.parsed_line[3]))
                ℓ.parsed_line[3] = string(name_of_states[ℓ.parsed_line[3]])  
            end
        end
    end

    if !isempty(name_of_states_obs)
        # Different parsing if we are reading a value line
        if typeof(ℓ) == SizeEqualFive
            if 4 in indices
                if isnothing(tryparse(Int64, ℓ.parsed_line[4]))
                    ℓ.parsed_line[4] = string(name_of_states[ℓ.parsed_line[4]])  
                end
            end
            
            if 5 in indices
                if isnothing(tryparse(Int64, ℓ.parsed_line[5]))
                    ℓ.parsed_line[5] = string(name_of_states_obs[ℓ.parsed_line[5]])  
                end
            end
        else
            if 4 in indices
                if isnothing(tryparse(Int64, ℓ.parsed_line[4]))
                    ℓ.parsed_line[4] = string(name_of_states_obs[ℓ.parsed_line[4]])  
                end
            end
        end
    end

    if !isempty(name_of_actions)
        if 2 in indices
            if isnothing(tryparse(Int64, ℓ.parsed_line[2]))
                ℓ.parsed_line[2] = string(name_of_actions[ℓ.parsed_line[2]])  
            end
        end
    end
end

#######

struct DynamicTransition <: TypeOfTransition 
    pre_colon::String
    number_of_states::Int64
    number_of_actions::Int64

    permitted_names::Vector{String}
end

DynamicTransition() = DynamicTransition("", 0, 0, Vector{String}())

precolon(T::DynamicTransition) = T.pre_colon
numstates(T::DynamicTransition) = T.number_of_states
numactions(T::DynamicTransition) = T.number_of_actions
numobs(T::DynamicTransition) = T.number_of_states


initindex(::DynamicTransition) = Vector{NTuple{3, Int64}}() 
initvalue(::DynamicTransition) = Vector{Float64}()

allowablefields(T::DynamicTransition) = T.permitted_names
generate_prob(::DynamicTransition, prob, number_of_states, number_of_observations) = ProbStates{typeof(prob)}(prob, number_of_states)

savetrans(T::DynamicTransition, parsed_prob::OrderedDict{NTuple{3, Int64}, Float64}) = TransitionProb{Int64}(parsed_prob, numstates(T), numactions(T)) 

struct ObsTransition <: TypeOfTransition 
    pre_colon::String
    number_of_states::Int64
    number_of_actions::Int64
    number_of_observations::Int64

    permitted_names::Vector{String}
end

ObsTransition() = ObsTransition("", 0, 0, 0, Vector{String}())

precolon(O::ObsTransition) = O.pre_colon
numstates(O::ObsTransition) = O.number_of_states
numactions(O::ObsTransition) = O.number_of_actions
numobs(O::ObsTransition) = O.number_of_observations

initindex(::ObsTransition) = Vector{NTuple{3, Int64}}() 
initvalue(::ObsTransition) = Vector{Float64}()

allowablefields(O::ObsTransition) = O.permitted_names
generate_prob(::ObsTransition, prob, number_of_states, number_of_observations) = ProbObs{typeof(prob)}(prob, number_of_states, number_of_observations)

savetrans(O::ObsTransition, parsed_prob::OrderedDict{NTuple{3, Int64}, Float64}) = ObservationProb{Int64}(parsed_prob, numstates(O), numactions(O), numobs(O))

struct ValueTransition <: TypeOfTransition 
    pre_colon::String
    number_of_states::Int64
    number_of_actions::Int64
    number_of_observations::Int64
    
    permitted_names::Vector{String}
end

ValueTransition() = ValueTransition("", 0, 0, 0, Vector{String}()) 

precolon(R::ValueTransition) = R.pre_colon
numstates(R::ValueTransition) = R.number_of_states
numactions(R::ValueTransition) = R.number_of_actions
numobs(R::ValueTransition) = R.number_of_observations

initindex(::ValueTransition) = Vector{NTuple{4, Int64}}() 
initvalue(::ValueTransition) = Vector{Float64}()

allowablefields(R::ValueTransition) = R.permitted_names
generate_prob(::ValueTransition, prob, number_of_states, number_of_observations) = ProbObs{typeof(prob)}(prob, number_of_states, number_of_observations)

savetrans(R::ValueTransition, value_prob::OrderedDict{NTuple{4, Int64}, Float64}) = RewardValue{Int64}(value_prob, numstates(R), numactions(R), numobs(R))

struct ProbStates{T} <: ProbTrans where T 
    vector_prob::T
    number_of_states::Int64
end

vecprob(m::ProbStates) = m.vector_prob
numstates(m::ProbStates) = m.number_of_states
numobs(m::ProbStates) = m.number_of_states

struct ProbObs{T} <: ProbTrans where T 
    vector_prob::T
    number_of_states::Int64
    number_of_observations::Int64
end

vecprob(m::ProbObs) = m.vector_prob
numstates(m::ProbObs) = m.number_of_states
numobs(m::ProbObs) = m.number_of_observations

struct SizeEqualFive <: LineParsing 
    parsed_line::Vector{String}
end

line(ℓ::SizeEqualFive) = ℓ.parsed_line

struct SizeEqualFour <: LineParsing 
    parsed_line::Vector{String}
end

line(ℓ::SizeEqualFour) = ℓ.parsed_line

struct SizeEqualThree <: LineParsing 
    parsed_line::Vector{String}
end

line(ℓ::SizeEqualThree) = ℓ.parsed_line

struct SizeEqualTwo <: LineParsing 
    parsed_line::Vector{String}
end

line(ℓ::SizeEqualTwo) = ℓ.parsed_line

function update_prob!(indices::NTuple{4, Int64}, prob::Float64, prob_indices::Vector{NTuple{4, Int64}}, prob_values::Vector{Float64})
    push!(prob_indices, indices)
    push!(prob_values, prob)
end

function update_prob!(indices::NTuple{3, Int64}, prob::Float64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64})
    push!(prob_indices, indices)
    push!(prob_values, prob)
end

function update_prob!(indices::NTuple{2, Int64}, prob::Union{ProbObs, ProbStates}, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64})
    _number = numstates(prob)
    _prob = vecprob(prob)
    
    if isequal(_prob, "uniform") 
        prob_val = 1/_number*ones(_number) 
    elseif isequal(_prob, "identity")
        prob_val = zeros(_number)
        prob_val[indices[1]] = 1
    else
        prob_val = _prob
        @assert test_if_probability(prob_val)
    end

    for (next, value_prob) in enumerate(prob_val)
        ii = (indices..., next)
        push!(prob_indices, ii)
        push!(prob_values, value_prob)
    end
end

function update_prob!(input::Tuple{Int64}, prob::Float64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}, dim1::Int64, dim2::Int64)
    for current_state in 1:dim1
        for next_state in 1:dim2
            ii = (current_state, input..., next_state)
            push!(prob_indices, ii)
            push!(prob_values, prob)
        end
    end
end
    
function update_prob!(input::Tuple{Int64}, prob::Int64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}, dim1::Int64, dim2::Int64)
    for current_state in 1:dim1
        ii = (current_state, input..., current_state)
        push!(prob_indices, ii)
        push!(prob_values, prob)
    end
end

function update_prob!(input::Tuple{Int64}, prob::AbstractMatrix{Float64}, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}, dim1::Int64, dim2::Int64)
    for current_state in 1:dim1
        @assert test_if_probability(prob[current_state,:])
        for next_state in 1:dim2
            ii = (current_state, input..., next_state)
            push!(prob_indices, ii)
            push!(prob_values, prob[current_state, next_state])
        end
    end
end


function process_line!(ℓ::SizeEqualFive, prob::Float64, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_observations::Dict{String, Int64}, number_wild_cards::Int64, prob_indices::Vector{NTuple{4, Int64}}, prob_values::Vector{Float64})
    if number_wild_cards == 0
        turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2,3,4,5])

        current_state = parse(Int64, ℓ.parsed_line[3])
        input = parse(Int64, ℓ.parsed_line[2])
        next_state = parse(Int64, ℓ.parsed_line[4])
        obs = parse(Int64, ℓ.parsed_line[5])

    elseif number_wild_cards == 1
        if isequal(ℓ.parsed_line[2], "*") 
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [3,4,5])

            current_state = parse(Int64, ℓ.parsed_line[3])
            input = 0
            next_state = parse(Int64, ℓ.parsed_line[4])
            obs = parse(Int64, ℓ.parsed_line[5])

        elseif isequal(ℓ.parsed_line[3], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2,4,5])

            current_state = 0
            input = parse(Int64, ℓ.parsed_line[2])
            next_state = parse(Int64, ℓ.parsed_line[4])
            obs = parse(Int64, ℓ.parsed_line[5])

        elseif isequal(ℓ.parsed_line[4], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2,3,5])

            current_state = parse(Int64, ℓ.parsed_line[3])
            input = parse(Int64, ℓ.parsed_line[2])
            next_state = 0
            obs = parse(Int64, ℓ.parsed_line[5])

        elseif isequal(ℓ.parsed_line[5], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2,3,4])

            current_state = parse(Int64, ℓ.parsed_line[3])
            input = parse(Int64, ℓ.parsed_line[2])
            next_state = parse(Int64, ℓ.parsed_line[4])
            obs = 0
        end

    elseif number_wild_cards == 2
        if isequal(ℓ.parsed_line[2], "*") && isequal(ℓ.parsed_line[3], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [4, 5])

            current_state = 0
            input = 0
            next_state = parse(Int64, ℓ.parsed_line[4])
            obs = parse(Int64, ℓ.parsed_line[5]) 
        end
        
        if isequal(ℓ.parsed_line[2], "*") && isequal(ℓ.parsed_line[4], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [3, 5])

            current_state = parse(Int64, ℓ.parsed_line[3])
            input = 0
            next_state = 0
            obs = parse(Int64, ℓ.parsed_line[5]) 
        end
        
        if isequal(ℓ.parsed_line[2], "*") && isequal(ℓ.parsed_line[5], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [3, 4])

            current_state = parse(Int64, ℓ.parsed_line[3])
            input = 0
            next_state = parse(Int64, ℓ.parsed_line[4]) 
            obs = 0
        end
        
        if isequal(ℓ.parsed_line[3], "*") && isequal(ℓ.parsed_line[4], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2, 5])

            current_state = 0
            input = parse(Int64, ℓ.parsed_line[2])
            next_state = 0
            obs = parse(Int64, ℓ.parsed_line[5]) 
        end

        if isequal(ℓ.parsed_line[3], "*") && isequal(ℓ.parsed_line[5], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2, 4])

            current_state = 0
            input = parse(Int64, ℓ.parsed_line[2])
            obs = 0
            next_state = parse(Int64, ℓ.parsed_line[4]) 
        end
        
        if isequal(ℓ.parsed_line[4], "*") && isequal(ℓ.parsed_line[5], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2, 3])

            current_state = parse(Int64, ℓ.parsed_line[3]) 
            input = parse(Int64, ℓ.parsed_line[2])
            next_state = 0
            obs = 0
        end
    elseif number_wild_cards == 3
        if isequal(ℓ.parsed_line[2], "*") && isequal(ℓ.parsed_line[3], "*") && isequal(ℓ.parsed_line[4], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [5])

            current_state = 0
            input = 0
            next_state = 0
            obs = parse(Int64, ℓ.parsed_line[5])
        end

        if isequal(ℓ.parsed_line[2], "*") && isequal(ℓ.parsed_line[3], "*") && isequal(ℓ.parsed_line[5], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [4])

            current_state = 0
            input = 0
            next_state = parse(Int64, ℓ.parsed_line[4])
            obs = 0
        end
        
        if isequal(ℓ.parsed_line[2], "*") && isequal(ℓ.parsed_line[4], "*") && isequal(ℓ.parsed_line[5], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [3])

            current_state = parse(Int64, ℓ.parsed_line[3])
            input = 0
            next_state = 0
            obs = 0
        end
        
        if isequal(ℓ.parsed_line[3], "*") && isequal(ℓ.parsed_line[4], "*") && isequal(ℓ.parsed_line[5], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_observations, [2])

            current_state = 0
            input = parse(Int64, ℓ.parsed_line[2])
            next_state = 0
            obs = 0
        end
    elseif number_wild_cards == 4
        input = 0
        current_state = 0
        next_state = 0
        obs = 0
    end
    
    update_prob!((current_state, input, next_state, obs), prob, prob_indices, prob_values)
end

function process_line!(ℓ::SizeEqualFour, prob::Float64, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, number_wild_cards::Int64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64})
    if number_wild_cards == 0 
        turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [2, 3, 4]) # I may have to chande this function. Last parameter may not be needed
        
        input = parse(Int64, ℓ.parsed_line[2]) 
        current_state = parse(Int64, ℓ.parsed_line[3])
        next = parse(Int64, ℓ.parsed_line[4])

    elseif number_wild_cards == 1
        if isequal(ℓ.parsed_line[2], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [3,4]) 

            current_state = parse(Int64, ℓ.parsed_line[3])
            next = parse(Int64, ℓ.parsed_line[4])
            input = 0

        elseif isequal(ℓ.parsed_line[3], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [2,4]) 

            current_state = 0
            input = parse(Int64, ℓ.parsed_line[2])
            next = parse(Int64, ℓ.parsed_line[4])
        
        elseif isequal(ℓ.parsed_line[4], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [2,3]) 

            input = parse(Int64, ℓ.parsed_line[2])
            current_state = parse(Int64, ℓ.parsed_line[3])
            next = 0
        else
            error("Unable to parse the position of the wild card")
        end

    elseif number_wild_cards == 2 
        if isequal(ℓ.parsed_line[4], "*")
            if isequal(ℓ.parsed_line[3], "*")
                turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [2]) 

                input = parse(Int64, ℓ.parsed_line[2])
                current_state = 0
                next = 0
            elseif isequal(ℓ.parsed_line[2], "*")
                turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [3]) 

                current_state = parse(Int64, ℓ.parsed_line[3])
                input = 0
                next = 0
            else
                error("Unable to parse this line. Please check the file.")
            end
        elseif isequal(ℓ.parsed_line[2], "*") && isequal(ℓ.parsed_line[3], "*") 
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [4]) 

            next = parse(Int64, ℓ.parsed_line[4])
            input = 0
            current_state = 0
        else
            error("Unable to parse this line. Please check the file.")
        end
    elseif number_wild_cards == 3
        input = 0                        
        current_state = 0
        next = 0 
    else
        error("Unable to parse this line. Please check the file.")
    end
    
    update_prob!((current_state, input, next), prob, prob_indices, prob_values)
end

function process_line!(ℓ::SizeEqualThree, prob::Union{ProbObs, ProbStates}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, number_wild_cards::Int64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}) 
    if number_wild_cards == 0 
        turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [2,3]) # I may have to chande this function. Last parameter may not be needed

        input = parse(Int64, ℓ.parsed_line[2]) 
        current_state = parse(Int64, ℓ.parsed_line[3])

    elseif number_wild_cards == 1
        if isequal(ℓ.parsed_line[2], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [3])

            current_state = parse(Int64, ℓ.parsed_line[3])
            input = 0

        elseif isequal(ℓ.parsed_line[3], "*")
            turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [2])

            input = parse(Int64, ℓ.parsed_line[2]) 
            current_state = 0

        else
            error("Unable to parse this line")
        end
    elseif number_wild_cards == 2
        current_state = 0
        input = 0

    else
        error("Unable to parse this line")
    end
    update_prob!((current_state, input), prob, prob_indices, prob_values)
end

function process_line!(ℓ::SizeEqualTwo, prob::Union{ProbObs{T}, ProbStates{T}}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}) where T

    if isequal(ℓ.parsed_line[2], "*")
        input = 0
    elseif ℓ.parsed_line[2] in keys(name_of_actions)
        turn_into_number!(ℓ, name_of_states, name_of_actions, name_of_states_obs, [2])
        input = parse(Int64, ℓ.parsed_line[2])
    end

    update_prob!((input,), vecprob(prob), prob_indices, prob_values, numstates(prob), numobs(prob))
end

##################################

function process_transitions(μ::TypeOfTransition, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_states_obs::Dict{String, Int64}, file::Vector{String})
    number_of_states = numstates(μ)
    number_of_observations = numobs(μ)

    prob_indices = Vector{Tuple{Int64, Int64, Int64}}()
    prob_values = Vector{Float64}()

    fields_admissible = allowablefields(μ)

    for (index, lines) in enumerate(file)
        type_of_trans = precolon(μ)

        if isequal(get_before_colon(lines) |> strip, type_of_trans)
            parsed_line = string.(strip.(split(lines, ':')))
            
            # if length(parsed_line) == 5
            #     # R: <action> : <start-state> : <next-state> : <observation>
            #     checking_fifth_param = split(parsed_line[4], " ", limit=2) # variable used to check whether the parameter is in the next line
                
            #     # The code below puts the parameter (if any) within the a Vector{String} structure
            #     temp_str = string.(split(parsed_line[5]))
            #     parsed_line[5] = ""
            #     parsed_line = filter(x->!isempty(x), parsed_line)
            #     map(x->push!(parsed_line, x), temp_str)

            #     number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

            #     if length(checking_fourth_param) == 1 # parameter passed in the next line
            #         if !isnothing(tryparse(Float64, file[index + 1]))
            #             prob = parse(Float64, file[index + 1])
            #         else
            #             error("Unable to parse line $index")
            #         end

            #         process_line!(SizeEqualFive(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
            #     end
 

            if length(parsed_line) == 4 
                # T: <action> : <start-state> : <next-state> or
                # O: <action> : <start-state> : <next-state> or
                # R: <action> : <start-state> : <end-state>
                checking_fourth_param = split(parsed_line[4], " ", limit=2) # variable used to check whether the parameter is in the next line

                # The code below puts the parameter (if any) within the a Vector{String} structure
                temp_str = string.(split(parsed_line[4]))
                parsed_line[4] = ""
                parsed_line = filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_fourth_param) == 1 # parameter passed in the next line
                    if !isnothing(tryparse(Float64, file[index + 1]))
                        prob = parse(Float64, file[index + 1])
                    else
                        error("Unable to parse line $index")
                    end

                    process_line!(SizeEqualFour(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
                
                elseif length(checking_fourth_param) == 2 # parameter in the same line
                    if length(parsed_line) == 5
                            prob = parse(Float64, parsed_line[5])
                    else
                        error("Unable to parse line $index")
                        # @warn "I am assing this probability to one"
                        # prob = 1.
                    end

                    process_line!(SizeEqualFour(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
                else
                    error("Unable to process this file.")
                end

            elseif length(parsed_line) == 3
                # T: <action> : <start-state> or
                # O: <action> : <start-state> or
                # R: <action> : <start-state>
                checking_third_param = split(parsed_line[3], " ", limit=2)
                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_third_param) == 1 # The transition probability will be on the next line
                    next_line =  string.(split(file[index + 1])) 

                    if all(x -> !isnothing(tryparse(Float64, x)), next_line)
                        prob = map(x -> parse(Float64, x), next_line)

                    elseif next_line[1] in fields_admissible
                        prob = next_line[1]
                    else
                        error("I am not sure how to parse this line. Please check the file in line $index.")
                    end

                    process_line!(SizeEqualThree(parsed_line), generate_prob(typeof(μ)(), prob, number_of_states, number_of_observations), name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
               
                elseif length(checking_third_param) == 2  # the transition probability will be given in the same line
                    parsed_line[3] = ""
                    parsed_line = filter(x -> !isempty(x), parsed_line)
                    map(x -> push!(parsed_line,x), checking_third_param)
                
                    number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                    prob = strip(parsed_line[4]) |> split
                    prob = string.(prob)

                    if all(x -> !isnothing(tryparse(Float64, x)), prob)
                        prob = map(x -> parse(Float64, x), prob)
                    end
                    
                    process_line!(SizeEqualThree(parsed_line), generate_prob(typeof(μ)(), prob, number_of_states, number_of_observations), name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)

                else
                    error("I am not sure how to parse this line. Check the line $index in the file.")
                end
                    
            elseif length(parsed_line) == 2 
            # T : <action> or
            # O : <action>
                next_line = file[index + 1] |> strip

                if isequal(next_line, "uniform")
                    # numobs returns number of states if parsing state transitions
                    prob = 1/numobs(μ)
                elseif isequal(next_line, "identity")
                    prob = 1
                else
                    # numobs returns number of states if parsing state transitions
                    if index + number_of_states > length(file)
                        error("Unable to parse the file. Please check the dimension of the transition matrix.")
                    end

                    matrix_lines = file[index + 1:index + number_of_states]

                    if all(x -> !isnothing(tryparse.(Float64, split(x))), matrix_lines)
                        prob = hcat([parse.(Float64, split(row)) for row in matrix_lines]...)' 
                    end
                end
                
                process_line!(SizeEqualTwo(parsed_line), generate_prob(typeof(μ)(), prob, number_of_states, number_of_observations), name_of_states, name_of_actions, name_of_states_obs, prob_indices, prob_values)
            else
                error("Error while parsing the file.")
            end
        end
    end

    @assert length(prob_indices) == length(prob_values) "Error while constructing the transition probability. Keys and values must have the same size."
    parsed_prob = OrderedDict(key => prob_values[index] for (index, key) in enumerate(prob_indices))

    return savetrans(μ, parsed_prob) 
end


function _process_transitions(μ::TypeOfTransition, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_states_obs::Dict{String, Int64}, file::Vector{String})
    number_of_states = numstates(μ)
    number_of_observations = numobs(μ)

    prob_indices = initindex(μ) 
    prob_values = initvalue(μ) 

    fields_admissible = allowablefields(μ)

    for (index, lines) in enumerate(file)
        type_of_trans = precolon(μ)

        if isequal(get_before_colon(lines) |> strip, type_of_trans)
            parsed_line = string.(strip.(split(lines, ':')))

            if length(parsed_line) == 5
                # R: <action> : <start-state> : <next-state> : <observation>
                checking_fifth_param = split(parsed_line[5], " ", limit=2) # variable used to check whether the parameter is in the next line
                
                # The code below puts the parameter (if any) within the a Vector{String} structure
                temp_str = string.(split(parsed_line[5]))
                parsed_line[5] = ""
                parsed_line = filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_fifth_param) == 1 # parameter passed in the next line
                    println(parsed_line)
                    if !isnothing(tryparse(Float64, file[index + 1]))
                        prob = parse(Float64, file[index + 1])
                    else
                        error("Unable to parse line $index")
                    end

                    process_line!(SizeEqualFive(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)

                elseif length(checking_fifth_param) == 2 # parameter in the same line
                    if length(parsed_line) == 6
                            prob = parse(Float64, parsed_line[6])
                    else
                        error("Unable to parse line $index")
                    end
                    
                    process_line!(SizeEqualFive(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
                end

            elseif length(parsed_line) == 4 
                # T: <action> : <start-state> : <next-state> or
                # O: <action> : <start-state> : <next-state>
                checking_fourth_param = split(parsed_line[4], " ", limit=2) # variable used to check whether the parameter is in the next line

                # The code below puts the parameter (if any) within the a Vector{String} structure
                temp_str = string.(split(parsed_line[4]))
                parsed_line[4] = ""
                parsed_line = filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_fourth_param) == 1 # parameter passed in the next line
                    if !isnothing(tryparse(Float64, file[index + 1]))
                        prob = parse(Float64, file[index + 1])
                    else
                        error("Unable to parse line $index")
                    end

                    process_line!(SizeEqualFour(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
                
                elseif length(checking_fourth_param) == 2 # parameter in the same line
                    if length(parsed_line) == 5
                            prob = parse(Float64, parsed_line[5])
                    else
                        error("Unable to parse line $index")
                        # @warn "I am assing this probability to one"
                        # prob = 1.
                    end

                    process_line!(SizeEqualFour(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
                else
                    error("Unable to process this file.")
                end

            elseif length(parsed_line) == 3
                # T: <action> : <start-state> or
                # O: <action> : <start-state>
                checking_third_param = split(parsed_line[3], " ", limit=2)
                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_third_param) == 1 # The transition probability will be on the next line
                    next_line =  string.(split(file[index + 1])) 

                    if all(x -> !isnothing(tryparse(Float64, x)), next_line)
                        prob = map(x -> parse(Float64, x), next_line)

                    elseif next_line[1] in fields_admissible
                        prob = next_line[1]
                    else
                        error("I am not sure how to parse this line. Please check the file in line $index.")
                    end

                    process_line!(SizeEqualThree(parsed_line), generate_prob(typeof(μ)(), prob, number_of_states, number_of_observations), name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
               
                elseif length(checking_third_param) == 2  # the transition probability will be given in the same line
                    parsed_line[3] = ""
                    parsed_line = filter(x -> !isempty(x), parsed_line)
                    map(x -> push!(parsed_line,x), checking_third_param)
                
                    number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                    prob = strip(parsed_line[4]) |> split
                    prob = string.(prob)

                    if all(x -> !isnothing(tryparse(Float64, x)), prob)
                        prob = map(x -> parse(Float64, x), prob)
                    end
                    
                    process_line!(SizeEqualThree(parsed_line), generate_prob(typeof(μ)(), prob, number_of_states, number_of_observations), name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)

                else
                    error("I am not sure how to parse this line. Check the line $index in the file.")
                end
                    
            elseif length(parsed_line) == 2 
            # T : <action> or
            # O : <action>
                next_line = file[index + 1] |> strip

                if isequal(next_line, "uniform")
                    # numobs returns number of states if parsing state transitions
                    prob = 1/numobs(μ)
                elseif isequal(next_line, "identity")
                    prob = 1
                else
                    # numobs returns number of states if parsing state transitions
                    if index + number_of_states > length(file)
                        error("Unable to parse the file. Please check the dimension of the transition matrix.")
                    end

                    matrix_lines = file[index + 1:index + number_of_states]

                    if all(x -> !isnothing(tryparse.(Float64, split(x))), matrix_lines)
                        prob = hcat([parse.(Float64, split(row)) for row in matrix_lines]...)' 
                    end
                end
                
                process_line!(SizeEqualTwo(parsed_line), generate_prob(typeof(μ)(), prob, number_of_states, number_of_observations), name_of_states, name_of_actions, name_of_states_obs, prob_indices, prob_values)
            else
                error("Error while parsing the file.")
            end
        end
    end

    @assert length(prob_indices) == length(prob_values) "Error while constructing the transition probability. Keys and values must have the same size."
    parsed_prob = OrderedDict(key => prob_values[index] for (index, key) in enumerate(prob_indices))

    return savetrans(μ, parsed_prob) 
end







################ Auxiliary functions -- REWARD ################## 
# function turn_into_number_values!(parsed_line::Vector{String}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_observations::Dict{String, Int64}, indices::Vector{Int64})
#     # If we define numbers for states this function may not work well
#     if !isempty(name_of_states)
#         if 3 in indices
#             parsed_line[3] = string(name_of_states[parsed_line[3]])
#         end
#     end
#         if 4 in indices
#             if isnothing(tryparse(Int64, parsed_line[4]))
#                 parsed_line[4] = string(name_of_states[parsed_line[4]])
#             end
#         end
#     end

#     if !isempty(name_of_observations)
#         if 5 in indices
#             if isnothing(tryparse(Int64, parsed_line[5]))
#                 parsed_line[5] = string(name_of_observations[parsed_line[5]]) 
#             end
#         end
#     end
    
#     if !isempty(name_of_actions)
#         if 2 in indices
#             if isnothing(tryparse(Int64, parsed_line[2]))
#                 parsed_line[2] = string(name_of_actions[parsed_line[2]])
#             end
#         end
#     end
# end

function process_reward_function(number_of_states::Int64, number_of_actions::Int64, number_of_observations::Int64, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_observations::Dict{String, Int64}, files_values::Vector{String})
    # values_dic = Dict((states, actions, next_state, observations) => 0. for states in 1:number_of_states, actions in 1:number_of_actions, next_state in 1:number_of_states, observations in 1:number_of_observations)
    reward_index = Vector{NTuple{4, Int64}}()
    reward_values = Vector{Float64}()

    for (index, lines) in enumerate(files_values)
        if isequal(get_before_colon(lines) |> strip, "R")
            parsed_line = string.(strip.(split(lines, ':')))
            # print(parsed_line, "\n\n")

            if length(parsed_line) == 5
                temp_str = split(parsed_line[5], " ")
                parsed_line[5] = ""
                parsed_line= filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if number_wild_cards == 0
                    turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3,4,5])

                    current_state = parse(Int64, parsed_line[3])
                    input = parse(Int64, parsed_line[2])
                    next_state = parse(Int64, parsed_line[4])
                    obs = parse(Int64, parsed_line[5])

                    if length(parsed_line) == 6
                        values = parse(Float64, parsed_line[6])
                    else
                        @warn "I am setting the rewards/cost to be zero"
                        values = 0.
                    end
                    
                    push!(reward_index, (current_state, input, next_state, obs))
                    push!(reward_values, values)
                    
                elseif number_wild_cards == 1
                    if isequal(parsed_line[2], "*") 
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3,4,5])

                        current_state = parse(Int64, parsed_line[3])
                        next_state = parse(Int64, parsed_line[4])
                        obs = parse(Int64, parsed_line[5])
                        input = 0

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)

                    elseif isequal(parsed_line[3], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,4,5])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        next_state = parse(Int64, parsed_line[4])
                        obs = parse(Int64, parsed_line[5])

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    
                    elseif isequal(parsed_line[4], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3,5])

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3])
                        next_state = 0
                        obs = parse(Int64, parsed_line[5])

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    
                    elseif isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3,4])

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3])
                        next_state = parse(Int64, parsed_line[4])
                        obs = 0

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                elseif number_wild_cards == 2
                    if isequal(parsed_line[2], "*") && isequal(parsed_line[3], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end

                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [4, 5])

                        input = 0
                        current_state = 0
                        next_state = parse(Int64, parsed_line[4])
                        obs = parse(Int64, parsed_line[5]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[2], "*") && isequal(parsed_line[4], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                    
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3, 5])

                        current_state = parse(Int64, parsed_line[3])
                        obs = parse(Int64, parsed_line[5]) 
                        input = 0
                        next_state = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[2], "*") && isequal(parsed_line[5], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            # I NEED TO ALLOW REWARDS TO BE DEFINED IN THE NEXT LINE. Also check transition and observation probability
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end

                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3, 4])

                        current_state = parse(Int64, parsed_line[3])
                        input = 0
                        obs = 0
                        next_state = parse(Int64, parsed_line[4]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[3], "*") && isequal(parsed_line[4], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2, 5])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        next_state = 0
                        obs = parse(Int64, parsed_line[5]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                        
                    end

                    if isequal(parsed_line[3], "*") && isequal(parsed_line[5], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2, 4])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        obs = 0
                        next_state = parse(Int64, parsed_line[4]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[4], "*") && isequal(parsed_line[5], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            print(parsed_line, "\n\n")
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2, 3])

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3]) 
                        next_state = 0
                        obs = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                elseif number_wild_cards == 3
                    parsed_line = filter(x->!isempty(x), parsed_line)

                    if length(parsed_line) == 6
                        values = parse(Float64, parsed_line[6])
                    else
                        @warn "I am setting the rewards/cost to be zero \n\n"
                        values = 0.
                    end

                    if isequal(parsed_line[2], "*") && isequal(parsed_line[3], "*") && isequal(parsed_line[4], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [5])

                        obs = parse(Int64, parsed_line[5])
                        input = 0
                        current_state = 0
                        next_state = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end

                    if isequal(parsed_line[2], "*") && isequal(parsed_line[3], "*") && isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [4])

                        next_state = parse(Int64, parsed_line[4])
                        input = 0
                        current_state = 0
                        obs = 0

                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[2], "*") && isequal(parsed_line[4], "*") && isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3])

                        current_state = parse(Int64, parsed_line[3])
                        input = 0
                        next_state = 0
                        obs = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[3], "*") && isequal(parsed_line[4], "*") && isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        next_state = 0
                        obs = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                elseif number_wild_cards == 4
                    if length(parsed_line) == 6
                        values = parse(Float64, parsed_line[6])
                    else
                        @warn "I am setting the rewards/cost to be zero \n\n"
                        values = 0.
                    end

                    input = 0
                    current_state = 0
                    next_state = 0
                    obs = 0
                    
                    push!(reward_index, (current_state, input, next_state, obs))
                    push!(reward_values, values)
                end
            end
        end
    end

    @assert length(reward_index) == length(reward_values) "Error while constructing the transition probability. Keys and values must have the same size."
    value_prob = OrderedDict(key => reward_values[index] for (index, key) in enumerate(reward_index))

    return RewardValue{Int64}(value_prob, number_of_states, number_of_actions, number_of_observations)
end