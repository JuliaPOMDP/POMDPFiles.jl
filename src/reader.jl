const REGEX_FLOATING_POINT = r"[-+]?[0-9]*\.?[0-9]+"

"""
    Read a `.alpha` file as generated by pomdp-solve.
    Works the same was as `read_pomdp` in `POMDPXFile.jl`.

    The `.alpha` file format is recapped here as follows,
    see: http://www.pomdp.org/code/alpha-file-spec.html

    A set of vectors is the representation use for the value function and each
    vector has an action associated with it. The vectors represent the coefficients
    of a hyperplane passing through the origin. The format specified here is what is
    output from the 'pomdp-solve' program and what will be necessary for input to
    the 'pomdp-solve' program with the '-terminal_values' command line option.

    The format is simply:

    A
    V1 V2 V3 ... VN

    A
    V1 V2 V3 ... VN

    ...


    Where `A` is an action number and the `V1` through `VN` are real values
    representing the components of a particular vector that has the associated
    action. The action number is the 0-based index of the action as specificed in
    the input POMDP file. The vector represents the coefficients of a hyperplane
    representing one facet of the piecewise linear and convex value function.
    Note that the length of the lists needs to be equal to the number of states in
    the POMDP.

    To find which action is the "best" for a given set of alpha vectors, the belief
    state probabilities would be used in a dot product against each alpha vectors'
    coefficients. The action associated with the vector with the highest value is
    the best action to take for that belief state given the value function.
"""
function read_alpha(filename::AbstractString)
    lines = open(readlines, filename)

    alpha_vector_line_indeces = Int[]
    vector_length = -1

    for i in eachindex(lines)

        matches = collect((m.match for m = eachmatch(REGEX_FLOATING_POINT, lines[i])))

        if length(matches) > 1
            push!(alpha_vector_line_indeces, i)
            @assert occursin(r"^(\d)*$", lines[i-1]) "previous line must contain an action index"

            if vector_length == -1
                vector_length = length(matches)
            else
                @assert vector_length == length(matches) "vector length is inconsistent. Was $vector_length, is $(length(matches)) on line $i"
            end
        end
    end
    num_alpha_vectors = length(alpha_vector_line_indeces)

    # Initialize the Γ matrix.
    # The α-vectors are the columns
    alpha_vectors = Array{Float64}(undef, vector_length, num_alpha_vectors)

    # Initialize the alpha_actions vector
    # alpha_actions[i] is the index of the action associated with
    # the alpha-vector in the ith column of alpha_vectors
    # Note that these are 0-indexed
    alpha_actions = Array{Int}(undef, num_alpha_vectors)

    for (i,line_index) in enumerate(alpha_vector_line_indeces)
        alpha_actions[i] = parse(Int, lines[line_index-1])

        for (j,match) in enumerate(eachmatch(REGEX_FLOATING_POINT, lines[line_index]))
            alpha_vectors[j,i] = parse(Float64, match.match)
        end
    end

    return alpha_vectors, alpha_actions
end

function read_pomdp(filename::AbstractString)
    # All files are assumed to be without comments and without empty lines here. I need to create a file that remove comments and empty lines 
    # I am also assuming the the first line starts with the compulsory parameters. This must also be dealt with before calling the functions below

    lines = open(readlines, filename) |> remove_comments_and_white_space
    # Reading the preamble of the file
    test_preamble = (length(lines) < 200) ? check_preamble_fields(lines[1:end]) : check_preamble_fields(lines[1:200])

    discount, type_reward, actions, states, observations = process_preamble(test_preamble)

    # Processing the initial distribution
    regex_init_cond = r"\s*start include\s*:|\s*start exclude\s*:|\s*start\s*:"


    init_state_lines = findall(startswith.(lines, regex_init_cond)) 

    ss_dic = Dict{String, Int64}(nn => index for (index, nn) in enumerate(string.(states.names_of_states)))

    init_state_info = InitialStateParam()

    if !isempty(lines[init_state_lines])
        init_state_info = process_initial_distribution(states.number_of_states, ss_dic, lines[init_state_lines])
    end

    # # Processing transition probability

    sorted_fields = order_of_transition_reward_observation(lines, 1)

    files_transition = []
    files_obs = []
    files_values = []

    # Finding the chunk of the file with the transition, observation, and reward specifications
    for (index, (type_of_matrix, line_number)) in enumerate(sorted_fields)

        if index  < length(sorted_fields)
            range_spec = line_number:(sorted_fields[index+1][2] -1)
            if isequal(type_of_matrix, "T")
                files_transition = lines[range_spec]
            end
            if isequal(type_of_matrix, "O")
                files_obs = lines[range_spec]
            end
            if isequal(type_of_matrix, "R")
                files_values = lines[range_spec]
            end
        else
            range_spec = (line_number:length(lines))
            if isequal(type_of_matrix, "T")
                files_transition = lines[range_spec]
            end
            if isequal(type_of_matrix, "O")
                files_obs = lines[range_spec]
            end
            if isequal(type_of_matrix, "R")
                files_values = lines[range_spec]
            end
        end
    end

    dic_action = Dict(string(nn) => index for (index, nn) in enumerate(names(actions)))
    dic_states = Dict(string(nn) => index for (index, nn) in enumerate(names(states)))
    dic_obs = Dict(string(nn) => index for (index, nn) in enumerate(names(observations)))

    transition_prob = process_transition_probability(number(states), number(actions), dic_states, dic_action, dic_states, files_transition)

    obs_prob = process_observations_probability(number(states), number(actions), number(observations), dic_states, dic_action, dic_obs, files_obs)

    values_matrix = process_reward_function(number(states), number(actions), number(observations), dic_states, dic_action, dic_obs, files_values)

    pomdp_struc = FilePOMDP(number(states), number(actions), number(observations), init_state_info, discount[1], transition_prob, obs_prob, values_matrix)

    return SFilePOMDP(dic_states, dic_action, dic_obs, pomdp_struc)

end

############# Setting-up a test dataset ####################

function read_pomdp_dir(dir_path::String)
    temp_file = walkdir(dir_path)

    file_dir = []

    for general_struc in temp_file
        for file_names in general_struc[3]
            push!(file_dir,joinpath(general_struc[1],file_names))
        end
    end

    return file_dir
end

################ Auxiliary functions ##################
function test_if_probability(prob::Vector{Float64})
    between_0_1 = all(x -> 0 <= x <= 1, prob)
    return (between_0_1 && isapprox(sum(prob), 1; rtol=1e-3)) ? true : false
end

function remove_comments_and_white_space(file::AbstractVector{String})

    processed_file = []

    for line in file
        without_comments = replace(line, r"#.*" => "") |> strip

        if !isempty(without_comments)
            push!(processed_file, without_comments)
        end
    end

    admissible_strings = ["discount", "values", "states", "actions", "observations", "start", "start include", "start exclude"]

    for (index, line) in enumerate(processed_file)
        tt_line = string(line)
        before_colon = get_before_colon(tt_line) |> strip
        after_colon = get_after_colon(tt_line) |> strip

        # This part of the code is joining in the preamble to facilitate parsing. Otherwise we would have to add code to deal with the case where the parameters are passed in the next line
        if (before_colon in admissible_strings) && isempty(after_colon)
            processed_file[index] = before_colon * ":" * processed_file[index + 1]
            processed_file[index+1] = ""
        end
    end

    return Vector{String}(filter(x -> !isempty(x), processed_file))
end

function get_before_colon(line::String)
    regex_before_colon = r"([^:]*):"

    search_pattern = match(regex_before_colon, line)
    
    return !isnothing(search_pattern) ? replace(search_pattern.match, r":+" => "") : "none-found"
end

function get_after_colon(line::String)
    regex_after_colon = r":(.)*$"

    search_pattern = match(regex_after_colon, line)

    if !isnothing(search_pattern)
        return replace(search_pattern.match, r":+" => "")
    else
        return "none-found"
    end
end

function read_ordinal_file(file_name::String; state_size = 20)
    
    ordinal_names = open(readlines, file_name)[1:state_size]
    ordinal_names = map(x -> replace(get_after_colon(x), r"[\s+]" => ""), ordinal_names)

    return Dict([ordinal_names[i] => i for i in 1:state_size])
    
end

function convert_to_data_structure(field::String, preamble_config::Dict{String,String}) 

    entry = preamble_config[field]
    entry = replace(entry, r"\"+" => "")
    
    test_entry = tryparse(Int64, entry)

    if typeof(test_entry) == Int64
        param = test_entry
    else
        param = split(entry)
    end

    return param 
end

function deal_with_partial_numbers(ordinal_dictionary::Dict{String, Int64}, initial_state_param::String)

    init_state = split(initial_state_param)
    state_size = length(ordinal_dictionary)

    if all(x -> x in keys(ordinal_dictionary), init_state)

        support_of_distribution = Set{Int64}([ordinal_dictionary[key] for key in init_state])  
        temp = [ordinal_dictionary[key] for key in init_state]
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,temp], dims=2)

        return support_of_distribution, value_of_distribution
    elseif all(x -> tryparse(Int64, x) in values(ordinal_dictionary), init_state)

        init_state = map(x -> parse(Int64, x), init_state)
        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,init_state], dims=2)

        return support_of_distribution, value_of_distribution

    else
        return nothing, nothing
    end
end

function order_of_transition_reward_observation(file_lines::Vector{String}, start_line::Int64) 

    key_field = ["O", "T", "R"]
    regex_fields = Vector{String}()

    [push!(regex_fields, "\\s*$field\\s*:") for field in key_field]

    indices = map(x-> findfirst(startswith.(file_lines, Regex(x))), regex_fields)

    dict_scanning = Dict(field => indices[ii] for (ii, field) in enumerate(key_field)) 
    sorted_fields = sort(collect(pairs(dict_scanning)), by=x->x[2])

    return sorted_fields
end

function read_ordinal_file(file_name::String; state_size = 20)
    
    ordinal_names = open(readlines, file_name)[1:state_size]
    ordinal_names = map(x -> replace(get_after_colon(x), r"[\s+]" => ""), ordinal_names)

    return Dict([ordinal_names[i] => i for i in 1:state_size])
    
end

######### Auxiliary functions -- PREAMBLE ###############

function check_preamble_fields(file_lines::Vector{String})
    key_fields = ["discount", "values", "states", "actions", "observations"]
   
    organized_preamble = Dict{String, String}() 
    field_dict = Dict{String, Int64}()

    for field in key_fields
        reg_expr = Regex("\\s*$(field)\\s*:")
        index = findfirst(startswith.(file_lines, reg_expr))

        if !isnothing(index) 
            field_dict[field] = index
        else
            error("Missing field $(field) in the file")
        end
    end

    sorted_fields = sort(collect(field_dict), by = x -> x[2]) # sorting is necessary to deal with the case in which the parameters are specified in several lines

    for (counter, (field, index_in_file)) in enumerate(sorted_fields) # necessary to deal with in-between specifications
       
        if counter < length(sorted_fields)
            if sorted_fields[counter+1][2] - index_in_file == 1
                temp_match = get_after_colon(file_lines[index_in_file]) |> strip
            else
                range_spec = index_in_file:(sorted_fields[counter+1][2]-1)
                temp_match = join(file_lines[range_spec], " ") |> get_after_colon |> strip 
            end
        else
            other_fields = ["T", "O", "R", "start", "start include", "start exclude"]
            regex_other = ""

            # Construction regex to field other fields
            for (index, field) in enumerate(other_fields)
                regex_other *= "\\s*$(field)\\s*:"
                if index < length(other_fields)
                    regex_other *= "|"
                end
            end
            next_indices = findfirst(startswith.(file_lines, Regex(regex_other)))

            if isnothing(next_indices)
                error("Error while parsing the preamble. It seems the information about the transitions is missing from the file.")
            else
                if next_indices - index_in_file == 1 
                    temp_match = get_after_colon(file_lines[index_in_file]) |> strip
                else
                    range_spec = index_in_file:(next_indices-1)

                    temp_match = join(file_lines[range_spec], " ") |> get_after_colon |> strip
                end
            end

        end

        organized_preamble[field] = temp_match 
    end

    return Dict{String, String}(kk => mm for (kk,mm) in organized_preamble) 
end

function process_preamble(preamble_config::Dict{String, String})

    # checking discount syntax => it must be a float number
    entry = preamble_config["discount"]
    test_entry = tryparse(Float64, entry)
    discount_param = [(typeof(test_entry) == Float64) && (0 <= test_entry <= 1) ? test_entry : error("Discount parameter must be a number between zero and one") ]

    # checking value syntax => either "reward" or "cost"
    entry = preamble_config["values"]
    entry = replace(entry, r"[\"+]|[\s+]" => "")
    values_param = [(isequal(entry,"reward")) || (isequal(entry,"cost") || isequal(entry, "rewards") || isequal(entry, "costs")) ? entry : error("Invalid specification for the objective function.")]

    # checking actions syntax => either an integer or a collection of names
    actions_param = convert_to_data_structure("actions", preamble_config) 
    
    # checking states syntax => either an integer or a collection of names
    states_param = convert_to_data_structure("states", preamble_config) 

    # checking observation syntax => either an integer or a collection of names
    observations_param = convert_to_data_structure("observations", preamble_config)


    # IT IS MISSING TO TEST WHERE WE HAVE A VECTOR OF STRINGS HERE
    return discount_param, values_param, ActionsParam(actions_param), StateParam(states_param), ObservationParam(observations_param) 
end

################ Auxiliary functions -- INITIAL DISTRIBUTION ################## 

function process_initial_distribution_start(state_size::Int64, after_colon::String, name_of_states::Dict{String, Int64})

    aux_var = tryparse(Int64, after_colon)

    if !isnothing(aux_var) # testing whether is a number

        if aux_var > state_size
            error("Unable to parse the initial state since initial condition is larger than the size of the state space.")
        end

        value_of_distribution = Diagonal(ones(Float64, state_size))[:,aux_var]
        support_of_distribution = Set{Int64}(aux_var) 
        return InitialStateParam{Int64}(state_size, "dirac", support_of_distribution, value_of_distribution) 
        
    elseif all(x -> isa(x, Float64) && (x<=1) && (x>=0) , map(x->tryparse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))) # testing whether s₀_param is a probability vector

        value_of_distribution =  map(x->parse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))
        support_of_distribution =  Set(findall(x -> x > 0, value_of_distribution))
        return InitialStateParam{Int64}(state_size, "general distribution", support_of_distribution, value_of_distribution) 

    elseif isequal(replace(after_colon, r"[\"+]|[\s+]" => ""), "uniform") # testing initial state is uniform 

        value_of_distribution = (1/state_size)*ones(state_size)
        support_of_distribution = Set{Int64}([i for i in Base.OneTo(state_size)])

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution)

    elseif all(x -> x in keys(name_of_states), split(after_colon))

        init_state = map(x -> name_of_states[x], split(after_colon))

        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)
        
        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        

        ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 
        support_of_distribution, value_of_distribution = deal_with_partial_numbers(ordinal_dictionary, after_colon)

        if !isnothing(support_of_distribution) 
            return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
        else
            error("Unable to parse the initial distribution.")
        end
    end


end

function process_initial_distribution_start_include(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})

    init_state = split(after_colon)
    state_size = state_initial_param.size_of_states
    
    ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 


    if all(x -> tryparse(Int64, x) in 1:state_size, init_state) 

        adding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    elseif all(x -> x in keys(ordinal_dictionary), init_state)

        init_state = map(x -> ordinal_dictionary[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    elseif all(x -> x in keys(name_of_states), init_state)

        init_state = map(x -> name_of_states[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    else
        error("Unable to parse the start include line.")
    end

    return

end

function process_initial_distribution_start_exclude(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})

    init_state = split(after_colon)
    state_size = state_initial_param.size_of_states
    
    ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 

    if all(x -> isa(tryparse(Int64, x), Int64), init_state) 

        excluding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    elseif all(x -> x in keys(ordinal_dictionary), init_state)

        init_state = map(x -> ordinal_dictionary[x], init_state)
        excluding_set = Set{Int64}(init_state)
        
        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)    

    elseif all(x -> x in keys(name_of_states), init_state)


        init_state = map(x -> name_of_states[x], init_state)
        excluding_set = Set{Int64}(init_state)

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    else
        error("Unable to parse the start exclude line.")
    end
    
    return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
end

function process_initial_distribution(number_of_states::Int64, name_of_states::Dict{String, Int64}, initial_state_ocurrences::Vector{String})
    # According to the grammar this can either be a number, a probability distribution over states, or strings (uniform or ordinal description of states)

    initial_state_param = InitialStateParam(number_of_states)
    
    for line in initial_state_ocurrences

        type_init_state = get_before_colon(line)
        param_init = get_after_colon(line) 
       
        if isequal(type_init_state, "start")
            
            initial_state_param = process_initial_distribution_start(number_of_states, param_init, name_of_states)

        elseif isequal(type_init_state, "start include")

            initial_state_param = process_initial_distribution_start_include(initial_state_param, param_init, name_of_states)
            
        elseif isequal(type_init_state, "start exclude")

            initial_state_param = process_initial_distribution_start_exclude(initial_state_param, param_init, name_of_states)
        else
            error("Unable to parse the initial condition.")
        end
    end

    return initial_state_param

end

################ Auxiliary functions -- TRANSITION PROBABILITY ################## 

function turn_into_number!(parsed_line::Vector{String}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, indices::Vector{Int64})

    # the index parameter serves to select whether or not the entry is allowed to be substituted. This is essential to deal with the wild card

    if !isempty(name_of_states)
        if 3 in indices
            parsed_line[3] = string(name_of_states[parsed_line[3]])  
        end
    end

    if !isempty(name_of_states_obs)
        if 4 in indices
            parsed_line[4] = string(name_of_states_obs[parsed_line[4]]) 
        end
    end

    if !isempty(name_of_actions)
        if 2 in indices
            parsed_line[2] = string(name_of_actions[parsed_line[2]])
        end
    end
end

abstract type LineParsing end
abstract type ProbTrans end
abstract type TypeOfTransition end

struct DynamicTransition 
    pre_colon::String
    number_of_states::Int64
    number_of_actions::Int64
    number_of_observations::Int64

    permitted_names::Vector{String}
end

numstates(T::DynamicTransition) = T.number_of_states
numactions(T::DynamicTransition) = T.number_of_actions
numobs(T::DynamicTransition) = T.number_of_observations

allowablefields(T::DynamicTransition) = T.permitted_names
generate_prob(::DynamicTransition, prob, number_of_states) = ProbStates{typeof(prob)}(prob, number_of_states)
#  struct 
# end

struct ProbStates{T} <: ProbTrans where T 
    vector_prob::T
    number_of_states::Int64
end

vecprob(m::ProbStates) = m.vector_prob
numstates(m::ProbStates) = m.number_of_states
numobs(m::ProbStates) = m.number_of_states

struct ProbObs{T} <: ProbTrans where T 
    vector_prob::T
    number_of_observations::Int64
    number_of_states::Int64
end

vecprob(m::ProbObs) = m.vector_prob
numstates(m::ProbObs) = m.number_of_states
numobs(m::ProbObs) = m.number_of_observations

struct SizeEqualFour <: LineParsing 
    parsed_line::Vector{String}
end

line(ℓ::SizeEqualFour) = ℓ.parsed_line

struct SizeEqualThree <: LineParsing 
    parsed_line::Vector{String}
end

line(ℓ::SizeEqualThree) = ℓ.parsed_line

struct SizeEqualTwo <: LineParsing 
    parsed_line::Vector{String}
end

line(ℓ::SizeEqualTwo) = ℓ.parsed_line

function update_prob!(indices::NTuple{3, Int64}, prob::Float64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64})
     
    push!(prob_indices, indices)
    push!(prob_values, prob)
end

function update_prob!(indices::NTuple{2, Int64}, prob::Union{ProbObs, ProbStates}, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64})
    _number = numstates(prob)
    _prob = vecprob(prob)
    
    if isequal(_prob, "uniform") 
        prob_val = 1/_number*ones(_number) 
    elseif isequal(_prob, "identity")
        prob_val = zeros(_number)
        prob_val[indices[1]] = 1
    else
        prob_val = _prob
        @assert test_if_probability(prob_val)
    end

    for (next, value_prob) in enumerate(prob_val)
        ii = (indices..., next)
        push!(prob_indices, ii)
        push!(prob_values, value_prob)
    end
end

function update_prob!(input::Tuple{Int64}, prob::Float64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}, dim1::Int64, dim2::Int64)

    for current_state in 1:dim1
        for next_state in 1:dim2
            ii = (current_state, input..., next_state)
            push!(prob_indices, ii)
            push!(prob_values, prob)
        end
    end
end
    
function update_prob!(input::Tuple{Int64}, prob::Int64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}, dim1::Int64, dim2::Int64)

    for current_state in 1:dim1
        ii = (current_state, input..., current_state)
        push!(prob_indices, ii)
        push!(prob_values, prob)
    end
end

function update_prob!(input::Tuple{Int64}, prob::AbstractMatrix{Float64}, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}, dim1::Int64, dim2::Int64)

    for current_state in 1:dim1
        @assert test_if_probability(prob[current_state,:])
        for next_state in 1:dim2
            ii = (current_state, input..., next_state)
            push!(prob_indices, ii)
            push!(prob_values, prob[current_state, next_state])
        end
    end
end

function process_line!(ℓ::SizeEqualFour, prob::Float64, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, number_wild_cards::Int64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64})
    
    parsed_line = line(ℓ)

    if number_wild_cards == 0 
        turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [2, 3, 4]) # I may have to chande this function. Last parameter may not be needed
        
        input = parse(Int64, parsed_line[2]) 
        current_state = parse(Int64, parsed_line[3])
        next = parse(Int64, parsed_line[4])

    elseif number_wild_cards == 1
        if isequal(parsed_line[2], "*")
            turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [3,4]) 

            current_state = parse(Int64, parsed_line[3])
            next = parse(Int64, parsed_line[4])
            input = 0

        elseif isequal(parsed_line[3], "*")
            turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [2,4]) 

            current_state = 0
            input = parse(Int64, parsed_line[2])
            next = parse(Int64, parsed_line[4])
        
        elseif isequal(parsed_line[4], "*")
            turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [2,3]) 

            input = parse(Int64, parsed_line[2])
            current_state = parse(Int64, parsed_line[3])
            next = 0
        else
            error("Unable to parse the position of the wild card")
        end
    elseif number_wild_cards == 2 # I HAVE CHECKED THIS FUNCTIONS UP TO THIS POINT

        if isequal(parsed_line[4], "*")
            if isequal(parsed_line[3], "*")
                turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [2]) 

                input = parse(Int64, parsed_line[2])
                current_state = 0
                next = 0
            elseif isequal(parsed_line[2], "*")
                turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [3]) 

                current_state = parse(Int64, parsed_line[3])
                input = 0
                next = 0
            else
                error("Unable to parse this line. Please check the file.")
            end
        elseif isequal(parsed_line[2], "*") && isequal(parsed_line[3], "*") 
            turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [4]) 

            next = parse(Int64, parsed_line[4])
            input = 0
            current_state = 0
        else
            error("Unable to parse this line. Please check the file.")
        end
    elseif number_wild_cards == 3
        input = 0                        
        current_state = 0
        next = 0 
    else
        error("Unable to parse this line. Please check the file.")
    end
    
    # println("O:", (current_state,input,next), " ", prob)
    update_prob!((current_state, input, next), prob, prob_indices, prob_values)
end

function process_line!(ℓ::SizeEqualThree, prob::Union{ProbObs, ProbStates}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, number_wild_cards::Int64, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}) 

    parsed_line = line(ℓ)


    if number_wild_cards == 0 
        turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [2,3]) # I may have to chande this function. Last parameter may not be needed

        input = parse(Int64, parsed_line[2]) 
        current_state = parse(Int64, parsed_line[3])

    elseif number_wild_cards == 1
        
        if isequal(parsed_line[2], "*")
            turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [3])

            current_state = parse(Int64, parsed_line[3])
            input = 0

        elseif isequal(parsed_line[3], "*")
            turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [2])

            input = parse(Int64, parsed_line[2]) 
            current_state = 0

        else
            error("Unable to parse this line")
        end
    elseif number_wild_cards == 2
        current_state = 0
        input = 0
    else
        error("Unable to parse this line")
    end
    update_prob!((current_state, input), prob, prob_indices, prob_values)
end

function process_line!(ℓ::SizeEqualTwo, prob::Union{ProbObs{T}, ProbStates{T}}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_states_obs::Dict{String, Int64}, prob_indices::Vector{NTuple{3, Int64}}, prob_values::Vector{Float64}) where T

    parsed_line = line(ℓ)

    if isequal(parsed_line[2], "*")
        input = 0
    elseif parsed_line[2] in keys(name_of_actions)
        turn_into_number!(parsed_line, name_of_states, name_of_actions, name_of_states_obs, [2])

        input = parse(Int64, parsed_line[2])
    end

    update_prob!((input,), vecprob(prob), prob_indices, prob_values, numstates(prob), numobs(prob))
end

function process_transition_probability(number_of_states::Int64, number_of_actions::Int64, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_states_obs::Dict{String, Int64}, file::Vector{String})


    prob_indices = Vector{Tuple{Int64, Int64, Int64}}()
    prob_values = Vector{Float64}()


    for (index, lines) in enumerate(file)

        if isequal(get_before_colon(lines) |> strip, "T")
            parsed_line = string.(strip.(split(lines, ':')))

            if length(parsed_line) == 4 
                # T: <action> : <start-state> : <next-state>

                checking_fourth_param = split(parsed_line[4], " ", limit=2) # variable used to check whether the parameter is in the next line

                # The code below puts the parameter (if any) within the a Vector{String} structure
                temp_str = string.(split(parsed_line[4]))
                parsed_line[4] = ""
                parsed_line = filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_fourth_param) == 1 # parameter passed in the next line

                    if !isnothing(tryparse(Float64, file[index + 1]))
                        prob = parse(Float64, file[index + 1])
                    else
                        error("Unable to parse line $index")
                    end

                    process_line!(SizeEqualFour(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
                
                elseif length(checking_fourth_param) == 2 # parameter in the same line
                    if length(parsed_line) == 5
                            prob = parse(Float64, parsed_line[5])
                    else
                        error("Unable to parse line $index")
                        # @warn "I am assing this probability to one"
                        # prob = 1.
                    end

                    process_line!(SizeEqualFour(parsed_line), prob, name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
                else
                    error("TBI: transition probability")
                end

            elseif length(parsed_line) == 3
                # T: <action> : <start-state>

                checking_third_param = split(parsed_line[3], " ", limit=2)
                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_third_param) == 1 # The transition probability will be on the next line

                    next_line =  string.(split(file[index + 1])) 

                    if all(x -> !isnothing(tryparse(Float64, x)), next_line)
                        prob = map(x -> parse(Float64, x), next_line)

                    elseif isequal(next_line[1], "uniform")
                        prob = "uniform"

                    elseif isequal(next_line[1], "identity")
                        prob = "identity"
                    else
                        error("I am not sure how to parse this line. Please check the file in line $index.")
                    end

                    process_line!(SizeEqualThree(parsed_line), ProbStates(prob, number_of_states), name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)
               
                elseif length(checking_third_param) == 2  # the transition probability will be given in the same line
                    parsed_line[3] = ""
                    parsed_line = filter(x -> !isempty(x), parsed_line)
                    map(x -> push!(parsed_line,x), checking_third_param)
                
                    number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                    prob = strip(parsed_line[4]) |> split
                    prob = string.(prob)

                    if all(x -> !isnothing(tryparse(Float64, x)), prob)
                        prob = map(x -> parse(Float64, x), prob)
                    end
                   
                    process_line!(SizeEqualThree(parsed_line), ProbStates(prob, number_of_states), name_of_states, name_of_actions, name_of_states_obs, number_wild_cards, prob_indices, prob_values)

                else
                    error("I am not sure how to parse this line. Check the line $index in the file.")
                end
                    
            elseif length(parsed_line) == 2 
            # T : <action>

                next_line = file[index + 1] |> strip

                if isequal(next_line, "uniform")
                    prob = 1/number_of_states
                elseif isequal(next_line, "identity")
                    prob = 1
                else
                    if index + number_of_states > length(file)
                        error("Unable to parse the file. Please check the dimension of the transition matrix.")
                    end

                    matrix_lines = file[index + 1:index + number_of_states]

                    if all(x -> !isnothing(tryparse.(Float64, split(x))), matrix_lines)
                        prob = hcat([parse.(Float64, split(row)) for row in matrix_lines]...)' 
                    end
                end
                process_line!(SizeEqualTwo(parsed_line), ProbStates{typeof(prob)}(prob, number_of_states), name_of_states, name_of_actions, name_of_states_obs, prob_indices, prob_values)
            else
                error("Error while parsing the file.")
            end
                
        end
    end

    @assert length(prob_indices) == length(prob_values) "Error while constructing the transition probability. Keys and values must have the same size."

    parsed_prob = OrderedDict(key => prob_values[index] for (index, key) in enumerate(prob_indices))

    return TransitionProb{Int64}(parsed_prob, number_of_states, number_of_actions)
end

################ Auxiliary functions -- Observation probability ################## 

function process_observations_probability(number_of_states::Int64, number_of_actions::Int64, number_of_observations::Int64, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_observations::Dict{String, Int64}, file::Vector{String})

    prob_indices = Vector{Tuple{Int64, Int64, Int64}}()
    prob_values = Vector{Float64}()


    for (index, lines) in enumerate(file)

        if isequal(get_before_colon(lines) |> strip, "O")
            parsed_line = string.(strip.(split(lines, ':')))
            
            if length(parsed_line) == 4 
                # O: <action> : <start-state> : <next-state>
                
                checking_fourth_param = split(parsed_line[4], " ", limit=2) # variable used to check whether parameter is in the next line

                temp_str = string.(split(parsed_line[4]))
                parsed_line[4] = ""
                parsed_line = filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_fourth_param) == 1 # parameter passed in the next line 

                    if !isnothing(tryparse(Float64, file[index + 1]))
                        obs = parse(Float64, file[index + 1])
                    else
                        error("Unable to parse line $index")
                    end

                    process_line!(SizeEqualFour(parsed_line), obs, name_of_states, name_of_actions, name_of_observations, number_wild_cards, prob_indices, prob_values)

                elseif length(checking_fourth_param) == 2 # The probability will be in the same line
                    if length(parsed_line) == 5
                        obs = parse(Float64, parsed_line[5])
                    else
                        error("Unable to parse line $line")
                    end

                    process_line!(SizeEqualFour(parsed_line), obs, name_of_states, name_of_actions, name_of_observations, number_wild_cards, prob_indices, prob_values)

                end
                
            elseif length(parsed_line) == 3
                # O: <action> : <start-state>
 
                checking_third_param = split(parsed_line[3], " ", limit=2)
                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if length(checking_third_param) == 1 # The transition probability will be on the next line

                    next_line =  string.(split(file[index + 1])) 

                    if all(x -> !isnothing(tryparse(Float64, x)), next_line)
                        obs = map(x -> parse(Float64, x), next_line)

                    elseif isequal(next_line[1], "uniform")
                        obs = "uniform"
                    else
                        error("I am not sure how to parse this line. Please check the file in line $index.")
                    end

                    process_line!(SizeEqualThree(parsed_line), ProbObs(obs, number_of_observations, number_of_states), name_of_states, name_of_actions, name_of_observations, number_wild_cards, prob_indices, prob_values)
               
                elseif length(checking_third_param) == 2  # the transition probability will be given in the same line
                    
                    parsed_line[3] = ""
                    parsed_line = filter(x -> !isempty(x), parsed_line)
                    map(x -> push!(parsed_line,x), checking_third_param)
                
                    number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                    obs = strip(parsed_line[4]) |> split
                    obs = string.(obs)

                    if all(x -> !isnothing(tryparse(Float64, x)), obs)
                        obs = map(x -> parse(Float64, x), obs)
                    end
                   

                    process_line!(SizeEqualThree(parsed_line), ProbObs(obs, number_of_observations, number_of_states), name_of_states, name_of_actions, name_of_observations, number_wild_cards, prob_indices, prob_values)

                else
                    error("I am not sure how to parse this line. Check the line $index in the file.")
                end
            
            elseif length(parsed_line) == 2
                 # O: <actions> 
                next_line = file[index + 1] |> strip

                if isequal(next_line, "uniform")
                    obs = 1/number_of_observations

                    # println(parsed_line, " ", next_line)
                elseif isequal(next_line, "identity")
                    # println(parsed_line, " ", next_line)
                    obs = 1
                else
                    if index + number_of_observations > length(file)
                        error("Unable to parse the file. Please check the dimension of the transition matrix.")
                    end

                    matrix_lines = file[index + 1:index + number_of_states]

                    if all(x -> !isnothing(tryparse.(Float64, split(x))), matrix_lines)
                        obs = hcat([parse.(Float64, split(row)) for row in matrix_lines]...)' 
                    end

                    # println(parsed_line, " ", matrix_lines)
                end

                process_line!(SizeEqualTwo(parsed_line), ProbObs{typeof(obs)}(obs, number_of_observations, number_of_states), name_of_states, name_of_actions, name_of_observations, prob_indices, prob_values)

                # println(prob_indices, " ", prob_values)
            else
                error("Error while parsing the file.")
            end
        end
    end
    
    @assert length(prob_indices) == length(prob_values) "Error while constructing the transition probability. Keys and values must have the same size."

    parsed_prob = OrderedDict(key => prob_values[index] for (index, key) in enumerate(prob_indices))
    
    return ObservationProb{Int64}(parsed_prob, number_of_states, number_of_actions, number_of_observations)
end

################ Auxiliary functions -- REWARD ################## 

function turn_into_number_values!(parsed_line::Vector{String}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_observations::Dict{String, Int64}, indices::Vector{Int64})
    # If we define numbers for states this function may not work well

    if !isempty(name_of_states)
        if 3 in indices
            if isnothing(tryparse(Int64, parsed_line[3]))
                parsed_line[3] = string(name_of_states[parsed_line[3]])
            end
        end
        if 4 in indices
            if isnothing(tryparse(Int64, parsed_line[4]))
                parsed_line[4] = string(name_of_states[parsed_line[4]])
            end
        end
    end

    if !isempty(name_of_observations)
        if 5 in indices
            if isnothing(tryparse(Int64, parsed_line[5]))
                parsed_line[5] = string(name_of_observations[parsed_line[5]]) 
            end
        end
    end
    
    if !isempty(name_of_actions)
        if 2 in indices
            if isnothing(tryparse(Int64, parsed_line[2]))
                parsed_line[2] = string(name_of_actions[parsed_line[2]])
            end
        end
    end
end

function process_reward_function(number_of_states::Int64, number_of_actions::Int64, number_of_observations::Int64, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_observations::Dict{String, Int64}, files_values::Vector{String})

    # values_dic = Dict((states, actions, next_state, observations) => 0. for states in 1:number_of_states, actions in 1:number_of_actions, next_state in 1:number_of_states, observations in 1:number_of_observations)
    reward_index = Vector{NTuple{4, Int64}}()
    reward_values = Vector{Float64}()

    for (index, lines) in enumerate(files_values)
        if isequal(get_before_colon(lines) |> strip, "R")
            parsed_line = string.(strip.(split(lines, ':')))
            # print(parsed_line, "\n\n")

            if length(parsed_line) == 5
                temp_str = split(parsed_line[5], " ")
                parsed_line[5] = ""
                parsed_line= filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                if number_wild_cards == 0
                    turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3,4,5])

                    current_state = parse(Int64, parsed_line[3])
                    input = parse(Int64, parsed_line[2])
                    next_state = parse(Int64, parsed_line[4])
                    obs = parse(Int64, parsed_line[5])

                    if length(parsed_line) == 6
                        values = parse(Float64, parsed_line[6])
                    else
                        @warn "I am setting the rewards/cost to be zero"
                        values = 0.
                    end
                    
                    push!(reward_index, (current_state, input, next_state, obs))
                    push!(reward_values, values)
                    
                elseif number_wild_cards == 1
                    if isequal(parsed_line[2], "*") 
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3,4,5])

                        current_state = parse(Int64, parsed_line[3])
                        next_state = parse(Int64, parsed_line[4])
                        obs = parse(Int64, parsed_line[5])
                        input = 0

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)

                    elseif isequal(parsed_line[3], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,4,5])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        next_state = parse(Int64, parsed_line[4])
                        obs = parse(Int64, parsed_line[5])

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    
                    elseif isequal(parsed_line[4], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3,5])

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3])
                        next_state = 0
                        obs = parse(Int64, parsed_line[5])

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    
                    elseif isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3,4])

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3])
                        next_state = parse(Int64, parsed_line[4])
                        obs = 0

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                elseif number_wild_cards == 2

                    if isequal(parsed_line[2], "*") && isequal(parsed_line[3], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end

                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [4, 5])

                        input = 0
                        current_state = 0
                        next_state = parse(Int64, parsed_line[4])
                        obs = parse(Int64, parsed_line[5]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[2], "*") && isequal(parsed_line[4], "*")

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                    
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3, 5])

                        current_state = parse(Int64, parsed_line[3])
                        obs = parse(Int64, parsed_line[5]) 
                        input = 0
                        next_state = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[2], "*") && isequal(parsed_line[5], "*")

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            # I NEED TO ALLOW REWARDS TO BE DEFINED IN THE NEXT LINE. Also check transition and observation probability
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end

                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3, 4])

                        current_state = parse(Int64, parsed_line[3])
                        input = 0
                        obs = 0
                        next_state = parse(Int64, parsed_line[4]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[3], "*") && isequal(parsed_line[4], "*")
                        # println(parsed_line)

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2, 5])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        next_state = 0
                        obs = parse(Int64, parsed_line[5]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                        
                    end

                    if isequal(parsed_line[3], "*") && isequal(parsed_line[5], "*")

                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2, 4])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        obs = 0
                        next_state = parse(Int64, parsed_line[4]) 
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[4], "*") && isequal(parsed_line[5], "*")
                        if length(parsed_line) == 6
                            values = parse(Float64, parsed_line[6])
                        else
                            print(parsed_line, "\n\n")
                            @warn "I am setting the rewards/cost to be zero \n\n"
                            values = 0.
                        end
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2, 3])

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3]) 
                        next_state = 0
                        obs = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                elseif number_wild_cards == 3

                    parsed_line = filter(x->!isempty(x), parsed_line)

                    if length(parsed_line) == 6
                        values = parse(Float64, parsed_line[6])
                    else
                        @warn "I am setting the rewards/cost to be zero \n\n"
                        values = 0.
                    end

                    if isequal(parsed_line[2], "*") && isequal(parsed_line[3], "*") && isequal(parsed_line[4], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [5])

                        obs = parse(Int64, parsed_line[5])
                        input = 0
                        current_state = 0
                        next_state = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end

                    if isequal(parsed_line[2], "*") && isequal(parsed_line[3], "*") && isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [4])

                        next_state = parse(Int64, parsed_line[4])
                        input = 0
                        current_state = 0
                        obs = 0

                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[2], "*") && isequal(parsed_line[4], "*") && isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3])

                        current_state = parse(Int64, parsed_line[3])
                        input = 0
                        next_state = 0
                        obs = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                    
                    if isequal(parsed_line[3], "*") && isequal(parsed_line[4], "*") && isequal(parsed_line[5], "*")
                        turn_into_number_values!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2])

                        input = parse(Int64, parsed_line[2])
                        current_state = 0
                        next_state = 0
                        obs = 0
                        
                        push!(reward_index, (current_state, input, next_state, obs))
                        push!(reward_values, values)
                    end
                elseif number_wild_cards == 4

                    if length(parsed_line) == 6
                        values = parse(Float64, parsed_line[6])
                    else
                        @warn "I am setting the rewards/cost to be zero \n\n"
                        values = 0.
                    end

                    input = 0
                    current_state = 0
                    next_state = 0
                    obs = 0
                    
                    push!(reward_index, (current_state, input, next_state, obs))
                    push!(reward_values, values)

                end

            end
        end
    end

    @assert length(reward_index) == length(reward_values) "Error while constructing the transition probability. Keys and values must have the same size."

    value_prob = OrderedDict(key => reward_values[index] for (index, key) in enumerate(reward_index))

    return RewardValue{Int64}(value_prob, number_of_states, number_of_actions, number_of_observations)
end

############ GENERATING JULIA CODE WITH THE INFORMATION READ ########################

function generate_julia_pomdp_struct(name_of_file::String, name_of_POMDP::String) 

    packages_def = """

    using POMDPs, Distributions, POMDPModelTools
    """

    struct_def = """
    struct $name_of_POMDP <: POMDP{Int, Int, Int} 
        number_of_states::Int64
        name_of_states::Vector{String}

        number_of_actions::Int64
        name_of_actions::Vector{String}

        number_of_observations::Int64
        name_of_observations::Vector{String}

        support_of_distribution::Set{Int64}
        value_of_distribution::Vector{Float64}

        discount::Float64

        T::TransitionProb
        O::ObservationProb
        R::RewardLookUp
    end
    """

    constructor_def = """

    $name_of_POMDP(s::StateParam, a::ActionsParam, o::ObservationParam, initial_state::InitialStateParam, discount::Float64, T::TransitionProb, O::ObservationProb, R::RewardLookUp)= $name_of_POMDP(s.number_of_states, s.names_of_states, a.number_of_actions, a.names_of_actions, o.number_of_observations, o.names_of_observations, initial_state.support_of_distribution, initial_state.value_of_distribution, discount, T, O, R)

    $name_of_POMDP(s::StateParam, a::ActionsParam, o::ObservationParam, discount::Float64, T::TransitionProb, O::ObservationProb, R::RewardLookUp) = $name_of_POMDP(s.number_of_states, s.names_of_states, a.number_of_actions, a.names_of_actions, o.number_of_observations, o.names_of_observations, [], [], discount, T, O, R)
    """

    states_def = """

    states(m::$name_of_POMDP) = 1:m.number_of_states
    stateindex(m::$name_of_POMDP, i::Int64) = (i <= m.number_of_states) ? i : error("Querying states outside the allowable range.")
    """

    actions_def = """

    actions(m::$name_of_POMDP) = 1:m.number_of_actions
    actionindex(m::$name_of_POMDP, i::Int64) = (i <= m.number_of_actions) ? i : error("Querying input outside the allowable range.")
    """

    obs_def = """

    observations(m::$name_of_POMDP) = 1:m.number_of_observations
    obsindex(m::$name_of_POMDP, i::Int64) = (i <= m.number_of_observations) ? i : error("Querying observations outside the allowable range.")
    """

    initial_state_def = """

    function initialstate(m::$name_of_POMDP)

        if !isempty(m.value_of_distribution)
            return SparseCat(1:m.number_of_states, m.value_of_distribution)
        else
            @warn "No available initial condition."
            return false
        end
    end
    """

    transition_def = """

    function transition(m::$name_of_POMDP, s::Int64, a::Int64)

        prob_val = [m.T[(s,a,sp)] for sp in 1:m.number_of_states]

        return SparseCat(1:m.number_of_states, prob_val)
    end

    transition(m::$name_of_POMDP, s::Int64, a::Int64, sp::Int64) = m.T[(s,a,sp)]
    """

    observation_def = """

    function observation(m::$name_of_POMDP, s::Int64, a::Int64)

        prob_obs = [m.O[(s, a, obs)] for obs in 1:m.number_of_observations]

        return SparseCat(1:m.number_of_observations, prob_obs)
    end

    observation(m::$name_of_POMDP, s::Int64, a::Int64, obs::Int64) = m.O[(s,a,obs)]
    """

    reward_def = """

    reward(m::$name_of_POMDP, s::Int64, a::Int64, sp::Int64, obs::Int64) = m.R[(s,a,sp,obs)]

    reward(m::$name_of_POMDP, s::Int64, a::Int64, sp::Int64) = m.R[(s,a,sp,1)]
    
    reward(m::$name_of_POMDP, s::Int64, a::Int64) = m.R[(s,a,1,1)]
    """

    discount_def = """
    
    discount(m::$name_of_POMDP) = m.discount
    """

    open(name_of_file, "w") do io

        println(io, packages_def)

        println(io, struct_def*constructor_def)
        println(io, states_def*actions_def*obs_def*initial_state_def)
        println(io, transition_def*observation_def*reward_def)

        println(io, discount_def)
    end
    
end

################ RETURNED TYPES BY READ FILES ###############################

# Integer  data structure

# struct FilePOMDP{Int64} <: POMDP{Int64, Int64, Int64} 
#     number_of_states::Int64
#     number_of_actions::Int64
#     number_of_observations::Int64

#     support_of_distribution::Set{Int64}
#     value_of_distribution::Vector{Float64}

#     discount::Float64

#     T::TransitionProb
#     O::ObservationProb
#     R::RewardLookUp
# end

# FilePOMDP(s::Int64, a::Int64, o::Int64, initial_state::InitialStateParam, discount::Float64, T::TransitionProb, O::ObservationProb, R::RewardLookUp)= FilePOMDP(s, a, o, support(initial_state), prob(initial_state), discount, T, O, R)  

# states(m::FilePOMDP{Int64}) = 1:m.number_of_states
# stateindex(m::FilePOMDP{Int64}, i::Int64) = (i <= m.number_of_states) ? i : error("Querying states outside the allowable range.")

# actions(m::FilePOMDP{Int64}) = 1:m.number_of_actions
# actionindex(m::FilePOMDP{Int64}, i::Int64) = (i <= m.number_of_actions) ? i : error("Querying input outside the allowable range.")

# observations(m::FilePOMDP{Int64}) = 1:m.number_of_observations
# obsindex(m::FilePOMDP{Int64}, i::Int64) = (i <= m.number_of_observations) ? i : error("Querying observations outside the allowable range.")

# function initialstate(m::FilePOMDP{Int64})

#     if !isempty(m.value_of_distribution)
#         return SparseCat(states(m), m.value_of_distribution)
#     else
#         @warn "No available initial condition."
#         return false
#     end
# end

# transition(m::FilePOMDP{Int64}, s::Int64, a::Int64, sp::Int64) = m.T[(s,a,sp)]

# function transition(m::FilePOMDP{Int64}, s::Int64, a::Int64)

#     prob_val = [transition(m, s, a, sp) for sp in states(m)]

#     return SparseCat(states(m), prob_val)
# end

# function observation(m::FilePOMDP{Int64}, s::Int64, a::Int64)

#     prob_obs = [m.O[(s, a, obs)] for obs in observations(m)]

#     return SparseCat(observations(m), prob_obs)
# end

# observation(m::FilePOMDP{Int64}, s::Int64, a::Int64, obs::Int64) = m.O[(s,a,obs)]

# reward(m::FilePOMDP{Int64}, s::Int64, a::Int64, sp::Int64, obs::Int64) = m.R[(s,a,sp,obs)]

# reward(m::FilePOMDP{Int64}, s::Int64, a::Int64, sp::Int64) = m.R[(s,a,sp,1)]

# reward(m::FilePOMDP{Int64}, s::Int64, a::Int64) = m.R[(s,a,1,1)]

# discount(m::FilePOMDP{Int64}) = m.discount

# # Data structure with names

# struct SFilePOMDP{String} <: POMDP{Int64, Int64, Int64}
#     dic_states::Dict{String, Int64}
#     dic_actions::Dict{String, Int64}
#     dic_obs::Dict{String, Int64}

#     pomdp::FilePOMDP{Int64}

#     function SFilePOMDP(dic_ss::Dict{String, Int64}, dic_aa::Dict{String, Int64}, dic_oo::Dict{String, Int64}, pomdp::FilePOMDP{Int64})

#         @assert length(dic_ss) == pomdp.number_of_states
#         @assert length(dic_aa) == pomdp.number_of_actions
#         @assert length(dic_oo) == pomdp.number_of_observations
        
#         new{String}(dic_ss, dic_aa, dic_oo, pomdp)

#     end
# end

# states(m::SFilePOMDP{String}) = states(m.pomdp)
# stateindex(m::SFilePOMDP{String}, key::Int64) = stateindex(m.pomdp, key)
# statenames(m::SFilePOMDP{String}) = collect(keys(m.dic_states))

# function stateindex(m::SFilePOMDP{String}, key::String) 
#     i = m.dic_states[key]
#     return stateindex(m, i)
# end

# actions(m::SFilePOMDP{String}) = actions(m.pomdp)
# actionindex(m::SFilePOMDP{String}, key::Int64) = actionindex(m.pomdp, key)
# actionnames(m::SFilePOMDP{String}) = collect(keys(m.dic_actions))

# function actionindex(m::SFilePOMDP{String}, key::String)
#     i = m.dic_actions[key]
#     return actionindex(m, i)
# end

# observations(m::SFilePOMDP{String}) = observations(m.pomdp)
# obsindex(m::SFilePOMDP{String}, i::Int64) = obsindex(m.pomdp, i) 
# obsnames(m::SFilePOMDP{String}) = collect(keys(m.dic_obs))

# function obsindex(m::SFilePOMDP{String}, key::String)
#     i = m.dic_obs[key]
#     return obsindex(m, i)
# end

# initialstate(m::SFilePOMDP{String}) = initialstate(m.pomdp)

# transition(m::SFilePOMDP{String}, s::Int64, a::Int64, sp::Int64) = transition(m.pomdp, s, a, sp)
# transition(m::SFilePOMDP{String}, s::Int64, a::Int64) = transition(m.pomdp, s, a)

# function transition(m::SFilePOMDP{String}, s::String, a::String, sp::String)
#     is = m.dic_states[s]; ia = m.dic_actions[a]; isp = m.dic_states[s]
#     return transition(m.pomdp, is, ia, isp)
# end

# function transition(m::SFilePOMDP{String}, s::String, a::String)
#    is = m.dic_states[s]; ia = m.dic_actions[a] 
#    return transition(m, is, ia)
# end

# observation(m::SFilePOMDP{String}, s::Int64, a::Int64, obs::Int64) = observation(m.pomdp, s, a, obs)
# observation(m::SFilePOMDP{String}, s::Int64, a::Int64) = observation(m.pomdp, s, a)

# function observation(m::SFilePOMDP, s::String, a::String, sp::String)
#     is = m.dic_states[s]; ia = m.dic_actions[a]; isp = m.dic_states[s]
#     return observation(m, is, ia, isp) 
# end

# function observation(m::SFilePOMDP, s::String, a::String)
#     is = m.dic_states[s]; ia = m.dic_actions[a] 
#     return observation(m, is, ia) 
# end

# reward(m::SFilePOMDP{String}, s::Int64, a::Int64, sp::Int64, obs::Int64) = reward(m.pomdp, s, a, sp, obs)
# reward(m::SFilePOMDP{String}, s::String, a::String, sp::String, obs::String) = reward(m.pomdp, m.dic_states[s], m.dic_actions[a], m.dic_states[sp], m.dic_obs[obs])

# reward(m::SFilePOMDP{String}, s::Int64, a::Int64, sp::Int64) = reward(m.pomdp, s, a, sp)
# reward(m::SFilePOMDP{String}, s::String, a::String, sp::String) = reward(m.pomdp, m.dic_states[s], m.dic_actions[a], m.dic_states[sp])

# reward(m::SFilePOMDP{String}, s::Int64, a::Int64) = reward(m.pomdp, s, a)
# reward(m::SFilePOMDP{String}, s::String, a::String) = reward(m.pomdp, m.dic_states[s], m.dic_actions[a])

# discount(m::SFilePOMDP) = discount(m.pomdp)


