const REGEX_FLOATING_POINT = r"[-+]?[0-9]*\.?[0-9]+"
"""
    Read a `.alpha` file as generated by pomdp-solve.
    Works the same was as `read_pomdp` in `POMDPXFile.jl`.

    The `.alpha` file format is recapped here as follows,
    see: http://www.pomdp.org/code/alpha-file-spec.html

    A set of vectors is the representation use for the value function and each
    vector has an action associated with it. The vectors represent the coefficients
    of a hyperplane passing through the origin. The format specified here is what is
    output from the 'pomdp-solve' program and what will be necessary for input to
    the 'pomdp-solve' program with the '-terminal_values' command line option.

    The format is simply:

    A
    V1 V2 V3 ... VN

    A
    V1 V2 V3 ... VN

    ...


    Where `A` is an action number and the `V1` through `VN` are real values
    representing the components of a particular vector that has the associated
    action. The action number is the 0-based index of the action as specificed in
    the input POMDP file. The vector represents the coefficients of a hyperplane
    representing one facet of the piecewise linear and convex value function.
    Note that the length of the lists needs to be equal to the number of states in
    the POMDP.

    To find which action is the "best" for a given set of alpha vectors, the belief
    state probabilities would be used in a dot product against each alpha vectors'
    coefficients. The action associated with the vector with the highest value is
    the best action to take for that belief state given the value function.
"""
function read_alpha(filename::AbstractString)
    lines = open(readlines, filename)

    alpha_vector_line_indeces = Int[]
    vector_length = -1

    for i in eachindex(lines)

        matches = collect((m.match for m = eachmatch(REGEX_FLOATING_POINT, lines[i])))

        if length(matches) > 1
            push!(alpha_vector_line_indeces, i)
            @assert occursin(r"^(\d)*$", lines[i-1]) "previous line must contain an action index"

            if vector_length == -1
                vector_length = length(matches)
            else
                @assert vector_length == length(matches) "vector length is inconsistent. Was $vector_length, is $(length(matches)) on line $i"
            end
        end
    end
    num_alpha_vectors = length(alpha_vector_line_indeces)

    # Initialize the Γ matrix.
    # The α-vectors are the columns
    alpha_vectors = Array{Float64}(undef, vector_length, num_alpha_vectors)

    # Initialize the alpha_actions vector
    # alpha_actions[i] is the index of the action associated with
    # the alpha-vector in the ith column of alpha_vectors
    # Note that these are 0-indexed
    alpha_actions = Array{Int}(undef, num_alpha_vectors)

    for (i,line_index) in enumerate(alpha_vector_line_indeces)
        alpha_actions[i] = parse(Int, lines[line_index-1])

        for (j,match) in enumerate(eachmatch(REGEX_FLOATING_POINT, lines[line_index]))
            alpha_vectors[j,i] = parse(Float64, match.match)
        end
    end

    return alpha_vectors, alpha_actions
end

function read_pomdp(filename::String; output::Symbol = :SFilePOMDP)
    lines = open(readlines, filename) |> remove_comments_and_white_space 
    # Reading the preamble of the file
    test_preamble = check_preamble_fields(lines)

    discount, type_reward, actions, states, observations = process_preamble(test_preamble)

    dic_action = Dict(string(nn) => index for (index, nn) in enumerate(names(actions)))
    dic_states = Dict(string(nn) => index for (index, nn) in enumerate(names(states)))
    dic_obs = Dict(string(nn) => index for (index, nn) in enumerate(names(observations)))
    

    # # Processing the initial distribution
    regex_init_cond = r"\s*start include\s*:|\s*start exclude\s*:|\s*start\s*:"
    init_state_lines = findall(startswith.(lines, regex_init_cond)) 
    init_state_info = InitialStateParam()

    if !isempty(lines[init_state_lines])
        init_state_info = process_initial_distribution(names(states), dic_states, lines[init_state_lines])
    end

    # # Processing transition probability

    sorted_fields = order_of_transition_reward_observation(lines, 1)

    files_transition = []
    files_obs = []
    files_values = []

    # Finding the chunk of the file with the transition, observation, and reward specifications
    for (index, (type_of_matrix, line_number)) in enumerate(sorted_fields)
        if index  < length(sorted_fields)
            range_spec = line_number:(sorted_fields[index+1][2] -1)
            if isequal(type_of_matrix, "T")
                files_transition = lines[range_spec]
            end
            if isequal(type_of_matrix, "O")
                files_obs = lines[range_spec]
            end
            if isequal(type_of_matrix, "R")
                files_values = lines[range_spec]
            end
        else
            range_spec = (line_number:length(lines))
            if isequal(type_of_matrix, "T")
                files_transition = lines[range_spec]
            end
            if isequal(type_of_matrix, "O")
                files_obs = lines[range_spec]
            end
            if isequal(type_of_matrix, "R")
                files_values = lines[range_spec]
            end
        end
    end

    # Processing observation probability
    str_trans = join(files_transition, "\n")
    vv = [string.(names(actions)), string.(names(states)), string.(names(states))]
    wc_trans = WildcardArrays.parse(str_trans, vv)

    # Processing observation probability
    str_obs = join(files_obs, "\n")
    vv = [string.(names(actions)), string.(names(states)), string.(names(observations))]
    wc_obs = WildcardArrays.parse(str_obs, vv)
    
    # Processing observation probability
    str_values = join(files_values, "\n")
    vv = [string.(names(actions)), string.(names(states)), string.(names(states)), string.(names(observations))]
    wc_values = WildcardArrays.parse(str_values, vv)
    
    pomdp_struc = FilePOMDP(number(states), number(actions), number(observations), init_state_info, discount[1], wc_trans, wc_obs, wc_values)

    if output == :FilePOMDP
        return pomdp_struc
    elseif output == :SFilePOMDP
        return SFilePOMDP(dic_states, dic_action, dic_obs, pomdp_struc)
    else
        error("Output type invalid")
    end
end

################ Auxiliary functions ##################
function test_if_probability(prob::Vector{Float64};rtol=1e-3)
    between_0_1 = all(x -> 0 <= x <= 1, prob)
    return (between_0_1 && isapprox(sum(prob), 1; rtol=rtol)) ? true : false
end

function remove_comments_and_white_space(file::Vector{String})
    processed_file = []

    for line in file
        without_comments = replace(line, r"#.*" => "") |> strip

        if !isempty(without_comments)
            push!(processed_file, without_comments)
        end
    end

    return Vector{String}(filter(x -> !isempty(x), processed_file))
end

function get_before_colon(line::String)
    regex_before_colon = r"([^:]*):"

    search_pattern = match(regex_before_colon, line)
    
    return !isnothing(search_pattern) ? replace(search_pattern.match, r":+" => "") : "none-found"
end

function get_after_colon(line::String)
    # println(length(line))
    if length(line) > 5000 # breaking in chunks of 5000
        number_chunks = div(length(line), 5000)
        # println(number_chunks)
        temp = "" 

        for ii in 1:number_chunks
            pre_process = ii < number_chunks ? _get_after_colon(line[(ii-1)*5000 + 1:ii*5000], ii) : _get_after_colon(line[((ii-1)*5000 +1):length(line)], ii)
            # println(pre_process)
            # println(typeof(pre_process))
            if !isequal(pre_process, "none-found")
                temp = temp*pre_process
            else
                error("Error while parsing the file.")
            end
        end
        return temp
    else
        return _get_after_colon(line, 1)    
    end
    
    @assert length(obs_prob_index) == length(obs_prob_values) "Error while constructing the transition probability. Keys and values must have the same size."
end

function _get_after_colon(line::String, ii::Int64)
    if ii == 1
        regex_after_colon = r":(.)*$"
        search_pattern = match(regex_after_colon, line)

        if !isnothing(search_pattern)
            return replace(search_pattern.match, r":+" => "")
        else
            return "none-found"
        end
    else
        return line
    end
end

function convert_to_data_structure(field::String, preamble::Dict{String,String}) 
    entry = preamble[field]
    entry = replace(entry, r"\"+" => "")

    return !isnothing(tryparse(Int64, entry)) ? parse(Int64, entry) : string.(split(entry))
end

function order_of_transition_reward_observation(file_lines::Vector{String}, start_line::Int64) 
    key_field = ["O", "T", "R"]
    regex_fields = Vector{String}()

    [push!(regex_fields, "\\s*$field\\s*:") for field in key_field]

    indices = map(x-> findfirst(startswith.(file_lines, Regex(x))), regex_fields)

    dict_scanning = Dict(field => indices[ii] for (ii, field) in enumerate(key_field)) 
    sorted_fields = sort(collect(pairs(dict_scanning)), by=x->x[2])

    return sorted_fields
end

######### Auxiliary functions -- PREAMBLE ###############

function check_preamble_fields(file_lines::Vector{String})
    key_fields = ["discount", "values", "states", "actions", "observations"]
    organized_preamble = Dict{String, String}() 
    field_dict = Dict{String, Int64}()

    for field in key_fields
        reg_expr = Regex("\\s*$(field)\\s*:")
        index = findfirst(startswith.(file_lines, reg_expr))

        if !isnothing(index) 
            field_dict[field] = index
        else
            error("Missing field $(field) in the file")
        end
    end

    sorted_fields = sort(collect(field_dict), by = x -> x[2]) # sorting is necessary to deal with the case in which the parameters are specified in several lines

    for (counter, (field, index_in_file)) in enumerate(sorted_fields) # necessary to deal with in-between specifications
       
        if counter < length(sorted_fields)
            if sorted_fields[counter+1][2] - index_in_file == 1
                temp_match = get_after_colon(file_lines[index_in_file]) |> strip
            else
                range_spec = index_in_file:(sorted_fields[counter+1][2]-1)
                temp_match = join(file_lines[range_spec], " ") |> get_after_colon |> strip 
            end
        else
            other_fields = ["T", "O", "R", "start", "start include", "start exclude"]
            regex_other = ""

            # Construction regex to field other fields
            for (index, field) in enumerate(other_fields)
                regex_other *= "\\s*$(field)\\s*:"
                if index < length(other_fields)
                    regex_other *= "|"
                end
            end
            next_indices = findfirst(startswith.(file_lines, Regex(regex_other)))

            if isnothing(next_indices)
                error("Error while parsing the preamble. It seems the information about the transitions is missing from the file.")
            else
                if next_indices - index_in_file == 1 
                    temp_match = get_after_colon(file_lines[index_in_file]) |> strip
                else
                    range_spec = index_in_file:(next_indices-1)

                    temp_match = join(file_lines[range_spec], " ") |> get_after_colon |> strip
                end
            end
        end

        organized_preamble[field] = temp_match 
    end

    return Dict{String, String}(kk => mm for (kk,mm) in organized_preamble) 
end

function process_preamble(preamble::Dict{String, String})
    # checking discount syntax => it must be a float number
    discount = parse(Float64, preamble["discount"])
    if ~(0 <= discount <= 1) 
        error("Discount parameter must be a number between zero and one") 
    end

    # checking value syntax => either "reward" or "cost"
    values_type = preamble["values"]
    values_type = replace(values_type, r"[\"+]|[\s+]" => "")
    values_param = [(isequal(values_type,"reward")) || (isequal(values_type,"cost") || isequal(values_type, "rewards") || isequal(values_type, "costs")) ? values_type : error("Invalid specification for the objective function.")]

    # checking actions syntax => either an integer or a collection of names
    actions_param = convert_to_data_structure("actions", preamble) 
    
    # checking states syntax => either an integer or a collection of names
    states_param = convert_to_data_structure("states", preamble) 

    # checking observation syntax => either an integer or a collection of names
    observations_param = convert_to_data_structure("observations", preamble)


    # IT IS MISSING TO TEST WHERE WE HAVE A VECTOR OF STRINGS HERE
    return discount, values_param, ContainerNames(actions_param), ContainerNames(states_param), ContainerNames(observations_param)
end

################ Auxiliary functions -- INITIAL DISTRIBUTION ################## 

function _process_initial_distribution_start(state_size::Int64, after_colon::String, name_of_states::Dict{String, Int64})
    aux_var = tryparse(Int64, after_colon)

    if all(map(x -> !isnothing(tryparse(Int64, x)), split(after_colon))) # testing whether is a number
        aux_var = map(x -> parse(Int64, x), split(after_colon))  

        if maximum(aux_var) > state_size
            error("Unable to parse the initial state since initial condition is larger than the size of the state space.")
        end

        value_of_distribution = Diagonal(ones(Float64, state_size))[:,aux_var]
        support_of_distribution = Set{Int64}(aux_var) 

        if length(aux_var) == 1
            return InitialStateParam{Int64}(state_size, "dirac", support_of_distribution, vec(value_of_distribution)) 
        else
            value_of_distribution = sum(value_of_distribution, dims=2) |> vec
            value_of_distribution = value_of_distribution/sum(value_of_distribution)
            return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution) 
        end
        
    elseif all(x -> isa(x, Float64) && (x<=1) && (x>=0) , map(x->tryparse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))) # testing whether initial distirbution is a probability vector
        value_of_distribution =  map(x->parse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))
        support_of_distribution =  Set(findall(x -> x > 0, value_of_distribution))
        return InitialStateParam{Int64}(state_size, "general distribution", support_of_distribution, value_of_distribution) 

    elseif isequal(replace(after_colon, r"[\"+]|[\s+]" => ""), "uniform") # testing initial state is uniform 
        value_of_distribution = (1/state_size)*ones(state_size)
        support_of_distribution = Set{Int64}([i for i in Base.OneTo(state_size)])

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution)

    elseif all(x -> x in keys(name_of_states), split(after_colon)) # where the initial distribution is passed with names
        init_state = map(x -> name_of_states[x], split(after_colon))

        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)
        
        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        error("Invalid syntax for the initial condition.")
    end
end

function _process_initial_distribution_start_include(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})
    init_state = split(after_colon)
    state_size = number(state_initial_param)
    
    if all(x -> tryparse(Int64, x) in 1:state_size, init_state) 
        adding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    elseif all(x -> x in keys(name_of_states), init_state)
        init_state = map(x -> name_of_states[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        error("Unable to parse the start include line.")
    end
end

function _process_initial_distribution_start_exclude(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})
    init_state = split(after_colon)
    state_size = state_initial_param.size_of_states
    
    if all(x -> isa(tryparse(Int64, x), Int64), init_state) 
        excluding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    elseif all(x -> x in keys(name_of_states), init_state)
        init_state = map(x -> name_of_states[x], init_state)
        excluding_set = Set{Int64}(init_state)

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    else
        error("Unable to parse the start exclude line.")
    end
    
    return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
end

function process_initial_distribution(number_of_states::Int64, name_of_states::Dict{String, Int64}, initial_state_ocurrences::Vector{String})
    # According to the grammar this can either be a number, a probability distribution over states, or strings (uniform or states' names)
    initial_state_param = InitialStateParam(number_of_states)
    
    for line in initial_state_ocurrences
        type_init_state = get_before_colon(line)
        param_init = get_after_colon(line) 
       
        if isequal(type_init_state, "start")
            initial_state_param = _process_initial_distribution_start(number_of_states, param_init, name_of_states)

        elseif isequal(type_init_state, "start include")
            initial_state_param = _process_initial_distribution_start_include(initial_state_param, param_init, name_of_states)
            
        elseif isequal(type_init_state, "start exclude")
            initial_state_param = _process_initial_distribution_start_exclude(initial_state_param, param_init, name_of_states)
        else
            error("Unable to parse the initial condition.")
        end
    end

    return initial_state_param
end