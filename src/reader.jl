const REGEX_FLOATING_POINT = r"[-+]?[0-9]*\.?[0-9]+"
using LinearAlgebra

"""
    Read a `.alpha` file as generated by pomdp-solve.
    Works the same was as `read_pomdp` in `POMDPXFile.jl`.

    The `.alpha` file format is recapped here as follows,
    see: http://www.pomdp.org/code/alpha-file-spec.html

    A set of vectors is the representation use for the value function and each
    vector has an action associated with it. The vectors represent the coefficients
    of a hyperplane passing through the origin. The format specified here is what is
    output from the 'pomdp-solve' program and what will be necessary for input to
    the 'pomdp-solve' program with the '-terminal_values' command line option.

    The format is simply:

    A
    V1 V2 V3 ... VN

    A
    V1 V2 V3 ... VN

    ...


    Where `A` is an action number and the `V1` through `VN` are real values
    representing the components of a particular vector that has the associated
    action. The action number is the 0-based index of the action as specificed in
    the input POMDP file. The vector represents the coefficients of a hyperplane
    representing one facet of the piecewise linear and convex value function.
    Note that the length of the lists needs to be equal to the number of states in
    the POMDP.

    To find which action is the "best" for a given set of alpha vectors, the belief
    state probabilities would be used in a dot product against each alpha vectors'
    coefficients. The action associated with the vector with the highest value is
    the best action to take for that belief state given the value function.
"""
function read_alpha(filename::AbstractString)
    lines = open(readlines, filename)

    alpha_vector_line_indeces = Int[]
    vector_length = -1

    for i in 1:length(lines)

        matches = collect((m.match for m = eachmatch(REGEX_FLOATING_POINT, lines[i])))

        if length(matches) > 1
            push!(alpha_vector_line_indeces, i)
            @assert occursin(r"^(\d)*$", lines[i-1]) "previous line must contain an action index"

            if vector_length == -1
                vector_length = length(matches)
            else
                @assert vector_length == length(matches) "vector length is inconsistent. Was $vector_length, is $(length(matches)) on line $i"
            end
        end
    end
    num_alpha_vectors = length(alpha_vector_line_indeces)

    # Initialize the Γ matrix.
    # The α-vectors are the columns
    alpha_vectors = Array{Float64}(undef, vector_length, num_alpha_vectors)

    # Initialize the alpha_actions vector
    # alpha_actions[i] is the index of the action associated with
    # the alpha-vector in the ith column of alpha_vectors
    # Note that these are 0-indexed
    alpha_actions = Array{Int}(undef, num_alpha_vectors)

    for (i,line_index) in enumerate(alpha_vector_line_indeces)
        alpha_actions[i] = parse(Int, lines[line_index-1])

        for (j,match) in enumerate(eachmatch(REGEX_FLOATING_POINT, lines[line_index]))
            alpha_vectors[j,i] = parse(Float64, match.match)
        end
    end

    return alpha_vectors, alpha_actions
end

function read_pomdp(filename::AbstractString)
    # All files are assumed to be without comments and without empty lines here. I need to create a file that remove comments and empty lines 
    # I am also assuming the the first line starts with the compulsory parameters. This must also be dealt with before calling the functions below

    lines = open(readlines, filename) |> remove_comments_and_white_space
    # Reading the preamble of the file
    test_preamble, ~ = check_preamble_fields(lines)
    discount, type_reward, actions, states, observations = processing_preamble(test_preamble)

    # Processing the initial distribution
    init_state_lines = get_all_occurences(lines, ["start", "start include", "start exclude"])

    if !isempty(states.names_of_states) 
        ss_dic = Dict{String, Int64}(nn => index for (index, nn) in enumerate(string.(states.names_of_states)))
    else
        ss_dic = Dict{String,Int64}()
    end

    if !isempty(states.number_of_states)
        init_state_lines_f = filter(x -> !isnothing(x), init_state_lines)
        init_state_info = processing_initial_distribution(states.number_of_states, ss_dic, lines[sort(init_state_lines_f)])
    end

    # Processing transition probability

    sorted_fields = order_of_transition_reward_observation(lines, 1)
    # print(sorted_fields[1][2])
    files_transition = []
    files_obs = []

    # Finding the chunk of the file with the transition, observation, and reward specifications
    for (index, (type_of_matrix, line_number)) in enumerate(sorted_fields)
        # print(index, " ", type_of_matrix, " ", line_number, "\n")

        if index + 1 <= length(sorted_fields)
            range_spec = line_number:(sorted_fields[index+1][2] -1)
            if isequal(type_of_matrix, "T")
                # print(typeof(lines))
                files_transition = lines[range_spec]
                # print("\n\n", files_transition, "\n\n")
            end
            if isequal(type_of_matrix, "O")
                # print(typeof(lines))
                files_obs = lines[range_spec]
                # print("\n\n", files_obs, "\n\n")
            end
            if isequal(type_of_matrix, "R")
                # print(typeof(lines))
                files_values = lines[range_spec]
                # print("\n\n", files_values, "\n\n")
            end
        else
            range_spec = (line_number:length(lines))
            if isequal(type_of_matrix, "T")
                # print(typeof(lines))
                files_transition = lines[range_spec]
                # print("\n\n", files_transition, "\n\n")
            end
            if isequal(type_of_matrix, "O")
                # print(typeof(lines))
                files_obs = lines[range_spec]
                # print("\n\n", files_obs, "\n\n")
            end
            if isequal(type_of_matrix, "R")
                # print(typeof(lines))
                files_values = lines[range_spec]
                # print("\n\n", files_values, "\n\n")
            end
        end
    end

    # print(typeof(files_transition), "\n\n")
    # print(files_transition, "\n\n")

    dic_action = Dict(string(name) => index for (index, name) in enumerate(actions.names_of_actions))
    dic_states = Dict(string(name) => index for (index, name) in enumerate(states.names_of_states))
    dic_obs = Dict(string(name) => index for (index, name) in enumerate(observations.names_of_observations))

        
    transition_prob = processing_transition_probability(states.number_of_states, actions.number_of_actions, dic_states, dic_action, files_transition)

    obs_prob = processing_observations_probability(states.number_of_states, actions.number_of_actions, observations.number_of_observations, dic_states, dic_action, dic_obs, files_obs)

    return transition_prob, obs_prob




    # if length(O_lines) > 0
    #     if length(findall(x->x==':', lines[O_lines[1]])) == 3
    #         for t in O_lines
    #             l = replace(lines[t], ':'=>' ')
    #             line = split(l, ' ')
    #             line = collect(strip(i) for i in line)
    #             deleteat!(line, findall(x->x=="", line))
    #             if line[4] == "*"
    #                 ind1 = collect(1:length(observations))
    #             else
    #                 ind1 = findall(x->x==line[4], observations)
    #             end
    #             if line[2] == "*"
    #                 ind2 = collect(1:length(actions))
    #             else
    #                 ind2 = findall(x->x==line[2], actions)
    #             end
    #             if line[3] == "*"
    #                 ind3 = collect(1:length(states))
    #             else
    #                 ind3 = findall(x->x==line[3], states)
    #             end
    #             O[ind1, ind2, ind3] .= parse(Float64, line[5])
    #         end
    #     elseif length(findall(x->x==':', lines[O_lines[1]])) == 2
    #         for t in T_lines
    #             l = t+1
    #             act = strip(split(lines[t], ':')[2])
    #             st = strip(split(lines[t], ':')[3])
    #             i = findfirst(x->x==act, actions)
    #             j = findfirst(x->x==st, states)
    #             O[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
    #         end
    #     else
    #         for t in O_lines
    #             l = t+1
    #             un = findall(strip(lines[l]), "uniform")
    #             act = strip(split(lines[t], ':')[2])
    #             if act == "*"
    #                 if length(un) > 0
    #                     for j in 1:num_states
    #                         for i in 1:num_actions
    #                             O[:,i,j] = ones(num_observations)./num_observations
    #                         end
    #                         l += 1
    #                     end
    #                 else
    #                     for j in 1:num_states
    #                         for i in 1:num_actions
    #                             O[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
    #                         end
    #                         l += 1
    #                     end
    #                 end
    #             else
    #                 i = findfirst(x->x==act, actions)
    #                 if length(un) > 0
    #                     for j in 1:num_states
    #                         O[:,i,j] = ones(num_observations)./num_observations
    #                         l += 1
    #                     end
    #                 else
    #                     for j in 1:num_states
    #                         O[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
    #                         l += 1
    #                     end
    #                 end
    #             end
    #         end
    #     end
    # end

    # if length(R_lines) > 0
    #     if length(findall(x->x==':', lines[R_lines[1]])) == 4
    #         for t in R_lines
    #             l = replace(lines[t], ':'=>' ')
    #             line = split(l, ' ')
    #             line = collect(strip(i) for i in line)
    #             deleteat!(line, findall(x->x=="", line))
    #             if line[3] == "*"
    #                 ind1 = collect(1:length(states))
    #             else
    #                 ind1 = findall(x->x==line[3], states)
    #             end
    #             if line[2] == "*"
    #                 ind2 = collect(1:length(actions))
    #             else
    #                 ind2 = findall(x->x==line[2], actions)
    #             end
    #             R[ind1, ind2] .= parse(Float64, line[6])
    #         end
    #     elseif length(findall(x->x==':', lines[R_lines[1]])) == 3
    #         for t in R_lines
    #             l = t+1
    #             act = strip(split(lines[t], ':')[2])
    #             i = findfirst(x->x==act, actions)
    #             for j in 1:num_states
    #                 T[j,i,:] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
    #                 l += 1
    #             end
    #         end
    #     else
    #         for t in R_lines
    #             l = t+1
    #             act = strip(split(lines[t], ':')[2])
    #             i = findfirst(x->x==act, actions)
    #             for j in 1:num_states
    #                 T[j,i,:] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
    #                 l += 1
    #             end
    #         end
    #     end
    # end

    # m = TabularPOMDP(T, R, O, discount)
    # return states, actions, type_reward, discount, observations, init_state_info
end




######################## Main structures ########################

struct ActionsParam 
    names_of_actions::Vector{SubString{String}}
    number_of_actions::Int
end

function ActionsParam(number_of_actions::Int)
    @warn "Defining the action names from 0 to $(number_of_actions-1)"
    names_of_actions = [string(i) for i in 0:(number_of_actions-1)]
    
    return ActionsParam(names_of_actions, number_of_actions)
end

# ActionsParam(number_of_actions::Int) = ActionsParam([],number_of_actions)
ActionsParam(names_of_actions::Vector{SubString{String}}) = ActionsParam(names_of_actions, length(names_of_actions))

struct StateParam 
    names_of_states::Vector{SubString{String}}
    number_of_states::Int
end

function StateParam(number_of_states::Int)
    @warn "Defining the states names from 0 to $(number_of_states-1)"
    names_of_states = [string(i) for i in 0:(number_of_states-1)]
    
    return StateParam(names_of_states, number_of_states)
end

# StateParam(number_of_states::Int) = StateParam([],number_of_states)
StateParam(name_of_states::Vector{SubString{String}}) = StateParam(name_of_states, length(name_of_states))

struct ObservationParam
    names_of_observations::Vector{SubString{String}}
    number_of_observations::Int
end

function ObservationParam(number_of_observations::Int)
    @warn "Defining the states names from 0 to $(number_of_observations-1)"
    names_of_observations = [string(i) for i in 0:(number_of_observations-1)]
    
    return ObservationParam(names_of_observations, number_of_observations)
end


# ObservationParam(number_of_observations::Int) = ObservationParam([],number_of_observations)
ObservationParam(names_of_observations::Vector{SubString{String}}) = ObservationParam(names_of_observations, length(names_of_observations))

struct InitialStateParam{T}

    size_of_states::T
    type_of_distribution::String
    support_of_distribution::Set{T}
    value_of_distribution::Vector{Float64}

    function InitialStateParam{T}(size_of_states::T, type_of_distribution::String, support_of_distribution::Set{T}, 
                            value_of_distribution::Vector{Float64}) where T<:Int64 
        # print(sum(value_of_distribution), "\n\n")
        # print(value_of_distribution, "\n\n")
        # Length of value_of_distribution must coincide with N, and all elements of support_of_distribution must be smaller, or equal to, N
        if isempty(type_of_distribution) 
            new{T}(size_of_states, "", Set{Int64}([]), Vector{Float64}([]))
        elseif (length(value_of_distribution) != size_of_states) || (collect(support_of_distribution) |> maximum) > size_of_states
            error("BLABLA")
        elseif !isapprox(sum(value_of_distribution),1, atol=1e-3) || any(x -> (x > 1) || (x < 0),  value_of_distribution) # checking whether value_of_distribution is a valid probability distribution
            error("BLABLA")
        else
            new{T}(size_of_states, type_of_distribution, support_of_distribution, value_of_distribution)
        end
    end
end

InitialStateParam() = InitialStateParam{Int64}(0, "", Set{Int64}([]), Vector{Float64}([])) 
InitialStateParam(size_of_states::Int64) = InitialStateParam{Int64}(size_of_states, "", Set{Int64}([]), Vector{Float64}([])) 

######## GETTING THE LINES FOR AN OCCURENCE OF A STRING IN THE FILE ##################

function get_all_occurences(source_file::Vector{String}, starting_line::Int64, key::String)

    removed_text = source_file[starting_line:end]
    all_occurences = findall(x -> isequal(get_before_semicolon(x), key), removed_text) 
   
    return isempty(all_occurences) ? nothing : all_occurences 
end

get_all_occurences(source_file::Vector{String}, key::String) = get_all_occurences(source_file, 1, key)
get_all_occurences(source_file::Vector{String}, multiple_keys::Vector{String}) = reduce(vcat, map(x -> get_all_occurences(source_file, x), multiple_keys))

get_first_occurence(source_file::Vector{String}, starting_line::Int64, key::String) = !isnothing(get_all_occurences(source_file, starting_line, key)) ? minimum(get_all_occurences(source_file, starting_line, key) .-1 .+starting_line) : nothing
get_first_occurence(source_file::Vector{String}, key::String) = get_first_occurence(source_file, 1, key) 

get_last_occurence(source_file::Vector{String}, starting_line::Int64, key::String) = !isnothing(get_all_occurences(source_file, starting_line, key)) ? maximum(get_all_occurences(source_file, starting_line, key) .-1 .+starting_line) : nothing
get_last_occurence(source_file::Vector{String}, key::String) = get_last_occurence(source_file, 1, key) 

function read_ordinal_file(file_name::String; state_size = 20)
    
    ordinal_names = open(readlines, file_name)[1:state_size]
    ordinal_names = map(x -> replace(get_after_semicolon(x), r"[\s+]" => ""), ordinal_names)

    return Dict([ordinal_names[i] => i for i in 1:state_size])
    
end

function dealing_with_partial_numbers(ordinal_dictionary::Dict{String, Int64}, initial_state_param::String)

    init_state = split(initial_state_param)
    state_size = length(ordinal_dictionary)

    if all(x -> x in keys(ordinal_dictionary), init_state)

        support_of_distribution = Set{Int63}([ordinal_dictionary[key] for key in init_state])  
        temp = [ordinal_dictionary[key] for key in init_state]
        value_of_distribution = (0/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,temp], dims=2)

        return support_of_distribution, value_of_distribution
    elseif all(x -> tryparse(Int63, x) in values(ordinal_dictionary), init_state)

        init_state = map(x -> parse(Int63, x), init_state)
        
        support_of_distribution = Set{Int63}(init_state)
        value_of_distribution = (0/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,init_state], dims=2)

        return support_of_distribution, value_of_distribution

    else
        return nothing, nothing
    end
end


############# Setting-up a test dataset ####################

function reading_pomdp_dir(dir_path::String)
    temp_file = walkdir(dir_path)

    file_dir = []

    for general_struc in temp_file
        for file_names in general_struc[3]
            push!(file_dir,joinpath(general_struc[1],file_names))
        end
    end

    return file_dir
end


################ Auxiliary functions ##################
function testing_if_probability(prob::Vector{Float64})
    between_0_1 = all(x -> 0 <= x <= 1, prob)
    return (between_0_1 && isapprox(sum(prob), 1)) ? true : false
end

function remove_comments_and_white_space(file::AbstractVector{String})

    processed_file = []

    for line in file
        without_comments = replace(line, r"#.*" => "") |> strip

        if !isempty(without_comments)
            push!(processed_file, without_comments)
        end
    end

    admissible_strings = ["discount", "values", "states", "actions", "observations", "start", "start include", "start exclude", "T", "O", "R"]

    for (index, line) in enumerate(processed_file)
        tt_line = string(line)
        before_semicolon = get_before_semicolon(tt_line) |> strip
        after_semicolon = get_after_semicolon(tt_line) |> strip


        if (before_semicolon in admissible_strings) && isempty(after_semicolon)
            processed_file[index] = before_semicolon * ":" * processed_file[index + 1]
            processed_file[index+1] = ""
        end
    end

    return Vector{String}(filter(x -> !isempty(x), processed_file))
end

function get_before_semicolon(line::String)
    regex_before_semicolon = r"([^:]*):"

    search_pattern = match(regex_before_semicolon, line)
    
    return !isnothing(search_pattern) ? replace(search_pattern.match, r":+" => "") : "none-found"
end

function get_after_semicolon(line::String)
    regex_after_semicolon = r":(.)*$"

    search_pattern = match(regex_after_semicolon, line)

    if !isnothing(search_pattern)
        return replace(search_pattern.match, r":+" => "")
    else
        return "none-found"
    end
end

function read_ordinal_file(file_name::String; state_size = 20)
    
    ordinal_names = open(readlines, file_name)[1:state_size]
    ordinal_names = map(x -> replace(get_after_semicolon(x), r"[\s+]" => ""), ordinal_names)

    return Dict([ordinal_names[i] => i for i in 1:state_size])
    
end


function convert_to_date_structure(field::String, preamble_config::Dict{String,Any}) 

    entry = preamble_config[field]
    entry = replace(entry, r"\"+" => "")
    test_entry = tryparse(Int, entry)

    if typeof(test_entry) == Int
        param = test_entry
    else
        param = split(entry)
    end

    return param 
end


function get_all_occurences(source_file::Vector{String}, starting_line::Int64, key::String)

    removed_text = source_file[starting_line:end]
    all_occurences = findall(x -> isequal(strip(get_before_semicolon(x)), key), removed_text) 
    
    return isempty(all_occurences) ? nothing : all_occurences 
end

get_all_occurences(source_file::Vector{String}, key::String) = get_all_occurences(source_file, 1, key)
get_all_occurences(source_file::Vector{String}, multiple_keys::Vector{String}) = reduce(vcat, map(x -> get_all_occurences(source_file, x), multiple_keys))

get_first_occurence(source_file::Vector{String}, starting_line::Int64, key::String) = !isnothing(get_all_occurences(source_file, starting_line, key)) ? minimum(get_all_occurences(source_file, starting_line, key) .-1 .+starting_line) : nothing
get_first_occurence(source_file::Vector{String}, key::String) = get_first_occurence(source_file, 1, key) 

function get_first_occurence(source_file::Vector{String}, key::Vector{String}) 

    temp_res = map(x->get_first_occurence(source_file, x), key)

    if all(x->isnothing(x), temp_res)
        return nothing
    elseif any(x->!isnothing(x), temp_res) 
        return minimum(filter(x->!isnothing(x), temp_res))
    else
        error("BLABLA")
    end

end

get_last_occurence(source_file::Vector{String}, starting_line::Int64, key::String) = !isnothing(get_all_occurences(source_file, starting_line, key)) ? maximum(get_all_occurences(source_file, starting_line, key) .-1 .+starting_line) : nothing
get_last_occurence(source_file::Vector{String}, key::String) = get_last_occurence(source_file, 1, key) 

function dealing_with_partial_numbers(ordinal_dictionary::Dict{String, Int64}, initial_state_param::String)

    init_state = split(initial_state_param)
    state_size = length(ordinal_dictionary)

    if all(x -> x in keys(ordinal_dictionary), init_state)

        support_of_distribution = Set{Int64}([ordinal_dictionary[key] for key in init_state])  
        temp = [ordinal_dictionary[key] for key in init_state]
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,temp], dims=2)

        return support_of_distribution, value_of_distribution
    elseif all(x -> tryparse(Int64, x) in values(ordinal_dictionary), init_state)

        init_state = map(x -> parse(Int64, x), init_state)
        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,init_state], dims=2)

        return support_of_distribution, value_of_distribution

    else
        return nothing, nothing
    end
end

function order_of_transition_reward_observation(file_lines::Vector{String}, start_line::Int64) 
    key_field = ["T", "O", "R"]
    dict_scanning = Dict(field => get_first_occurence(file_lines, field) for field in key_field)
    sorted_fields = sort(collect(pairs(dict_scanning)), by=x->x[2])

    return sorted_fields
end

######### Auxiliary functions -- PREAMBLE ###############

function get_between_lines(file_lines::Vector{String}) 
    single_line = join(file_lines, " ")
    return get_after_semicolon(single_line)
end

function check_preamble_fields(file_lines::Vector{String})
    key_fields = ["discount", "values", "states", "actions", "observations"]
    compulsory_fields = Set(key_fields) # compulsory fields according to the file format

    for field in key_fields
        if !isnothing(get_first_occurence(file_lines, field)) 
            compulsory_fields = setdiff(compulsory_fields, [field])
        else
            error("Missing field $(field) in the file")
        end
    end

    dict_scanning = Dict(field => get_first_occurence(file_lines, field) for field in key_fields)
    sorted_fields = sort(collect(pairs(dict_scanning)), by=x->x[2])

    organized_preamble = Dict{String, Any}() 

    for (ii, (field, field_values)) in enumerate(sorted_fields)
       

        if ii + 1 <= length(sorted_fields)
            if sorted_fields[ii+1][2] - field_values == 1
                temp_match = get_after_semicolon(file_lines[field_values]) 
            else
                range_spec = field_values:(sorted_fields[ii+1][2]-1)
                temp_match = get_between_lines(file_lines[range_spec])
            end
        else
            next_indices = get_first_occurence(file_lines, ["T", "O", "R", "start", "start include", "start exclude"])
            if next_indices - field_values == 1 
                temp_match = get_after_semicolon(file_lines[field_values])
            else
                range_spec = field_values:(next_indices-1)
                temp_match = get_between_lines(file_lines[range_spec])
            end
        end

        organized_preamble[field] = temp_match 
    end


    return organized_preamble, isempty(compulsory_fields) ? Nothing : error("BLABLA")
end

function processing_preamble(preamble_config::Dict{String, Any})

    # checking discount syntax => it must be a float number
    entry = preamble_config["discount"]
    test_entry = tryparse(Float64, entry)
    discount_param = [(typeof(test_entry) == Float64) && (0 <= test_entry <= 1) ? test_entry : error("BLABLA") ]

    # checking value syntax => either "reward" or "cost"
    entry = preamble_config["values"]
    entry = replace(entry, r"[\"+]|[\s+]" => "")
    values_param = [(isequal(entry,"reward")) || (isequal(entry,"cost") || isequal(entry, "rewards") || isequal(entry, "costs")) ? entry : error("BLABLA")]

    # checking actions syntax => either an integer or a collection of names
    actions_param = convert_to_date_structure("actions", preamble_config) 
    
    # checking states syntax => either an integer or a collection of names
    states_param = convert_to_date_structure("states", preamble_config) 

    # checking observation syntax => either an integer or a collection of names
    observations_param = convert_to_date_structure("observations", preamble_config)


    # IT IS MISSING TO TEST WHERE WE HAVE A VECTOR OF STRINGS HERE
    return discount_param, values_param, ActionsParam(actions_param), StateParam(states_param), ObservationParam(observations_param) 
end

################ Auxiliary functions -- INITIAL DISTRIBUTION ################## 

function processing_initial_distribution_start(state_size::Int64, after_semicolon::String, name_of_states::Dict{String, Int64})

    aux_var = tryparse(Int64, after_semicolon)

    if !isnothing(aux_var) # testing whether is a number

        if aux_var > state_size
            error("BLABLA")
        end

        value_of_distribution = Diagonal(ones(Float64, state_size))[:,aux_var]
        support_of_distribution = Set{Int64}(aux_var) 
        return InitialStateParam{Int64}(state_size, "dirac", support_of_distribution, value_of_distribution) 
        
    elseif all(x -> isa(x, Float64) && (x<=1) && (x>=0) , map(x->tryparse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_semicolon))) # testing whether s₀_param is a probability vector

        value_of_distribution =  map(x->parse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_semicolon))
        support_of_distribution =  Set(findall(x -> x > 0, value_of_distribution))
        return InitialStateParam{Int64}(state_size, "general distribution", support_of_distribution, value_of_distribution) 

    elseif isequal(replace(after_semicolon, r"[\"+]|[\s+]" => ""), "uniform") # testing initial state is uniform 

        value_of_distribution = (1/state_size)*ones(state_size)
        support_of_distribution = Set{Int64}([i for i in Base.OneTo(state_size)])

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution)

    elseif all(x -> x in keys(name_of_states), split(after_semicolon))

        init_state = map(x -> name_of_states[x], split(after_semicolon))

        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)
        
        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        

        ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 
        support_of_distribution, value_of_distribution = dealing_with_partial_numbers(ordinal_dictionary, after_semicolon)

        if !isnothing(support_of_distribution) 
            return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
        else
            error("BLABLA")
        end
    end


end

function processing_initial_distribution_start_include(state_initial_param::InitialStateParam, after_semicolon::String, name_of_states::Dict{String, Int64})

    init_state = split(after_semicolon)
    state_size = state_initial_param.size_of_states
    
    ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 


    if all(x -> tryparse(Int64, x) in 1:state_size, init_state) 

        adding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    elseif all(x -> x in keys(ordinal_dictionary), init_state)

        init_state = map(x -> ordinal_dictionary[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    elseif all(x -> x in keys(name_of_states), init_state)

        init_state = map(x -> name_of_states[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    else
        error("BLABLA")
    end

    # jk
    return

end

function processing_initial_distribution_start_exclude(state_initial_param::InitialStateParam, after_semicolon::String, name_of_states::Dict{String, Int64})

    init_state = split(after_semicolon)
    state_size = state_initial_param.size_of_states
    
    ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 

    if all(x -> isa(tryparse(Int64, x), Int64), init_state) 

        excluding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    elseif all(x -> x in keys(ordinal_dictionary), init_state)

        init_state = map(x -> ordinal_dictionary[x], init_state)
        excluding_set = Set{Int64}(init_state)
        
        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)    

    elseif all(x -> x in keys(name_of_states), init_state)


        init_state = map(x -> name_of_states[x], init_state)
        excluding_set = Set{Int64}(init_state)

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    else
        print("To be implemented")
    end
    
    return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
end

function processing_initial_distribution(number_of_states::Int64, name_of_states::Dict{String, Int64}, initial_state_ocurrences::Vector{String})
    # According to the grammar this can either be a number, a probability distribution over states, or strings (uniform or ordinal description of states)

    initial_state_param = InitialStateParam(number_of_states)
    
    for line in initial_state_ocurrences

        type_init_state = get_before_semicolon(line)
        param_init = get_after_semicolon(line) 
       
        if isequal(type_init_state, "start")
            
            initial_state_param = processing_initial_distribution_start(number_of_states, param_init, name_of_states)

        elseif isequal(type_init_state, "start include")

            initial_state_param = processing_initial_distribution_start_include(initial_state_param, param_init, name_of_states)
            
        elseif isequal(type_init_state, "start exclude")

            initial_state_param = processing_initial_distribution_start_exclude(initial_state_param, param_init, name_of_states)
        else
            error("BLABLA")
        end
    end

    return initial_state_param

end

################ Auxiliary functions -- TRANSITION PROBABILITY ################## 

function turn_into_number!(parsed_line::Vector{String}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, indices::Vector{Int64}, length_vv::Int64)

    # the index parameter serves to select whether or not the entry is allowed to be substituted. This is essential to deal with the wild card

    if length_vv == 4
        if !isempty(name_of_states)
            if 3 in indices
                parsed_line[3] = string(name_of_states[parsed_line[3]])  
            end

            if 4 in indices
                parsed_line[4] = string(name_of_states[parsed_line[4]]) 
            end
        end

        if !isempty(name_of_actions)
            if 2 in indices
                parsed_line[2] = string(name_of_actions[parsed_line[2]])
            end
        end
    end
end

function get_transition_prob_number_same_line!(current_state, input, prob, trans_prob, number_of_states)

    # print("I am in this function \n\n")

    if all(map(x -> !isnothing(tryparse(Float64,x)), prob)) && (length(prob) == number_of_states)
        prob = map(x->parse(Float64, x), prob)
        if testing_if_probability(prob)
            for (index, next_state) in enumerate(1:number_of_states)
                trans_prob[(current_state,input,next_state)] = prob[index]
            end
        else
            error("BLABLA")
        end
    else
        error("BLABLA")
    end
end

function get_transition_prob_next_line!(current_state::Int64, input::Int64, trans_prob::Dict{Tuple{Int64, Int64, Int64}, Float64}, index::Int64, number_of_states::Int64, files_trans::Vector{String})

    next_line =  string.(split(files_trans[index + 1])) 

    if all(x -> !isnothing(tryparse(Float64, x)), next_line)
        prob = map(x -> parse(Float64, x), next_line)

        if testing_if_probability(prob) && (length(prob) == number_of_states)

            for (next_state, value_prob) in enumerate(prob)
                trans_prob[(current_state, input, next_state)] = value_prob 
            end
            # NEED TO CONTINUE FROM HERE. MISSING POINTS:
            # 1. CHECK WHETHER * CAN APPEAR HERE
            # 2. ADD IDENTITY AND UNIFORM SETTING
        else
            error("BLABLA")
        end
    end
end

function get_transition_prob_matrix!()
    print("Hello!")
end


function processing_transition_probability(number_of_states::Int64, number_of_actions::Int64, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, trans_prob_occurences::Vector{String})


    trans_prob = Dict((states, actions, states_n) => 0. for states in 1:number_of_states, actions in 1:number_of_actions, states_n in 1:number_of_states)


    for (index, lines) in enumerate(trans_prob_occurences)

        if isequal(get_before_semicolon(lines) |> strip, "T")
            parsed_line = string.(strip.(split(lines, ':')))
            # print(parsed_line, "\n\n")
        
            # parsed = turn_into_number(parsed_line, name_of_states, name_of_actions) 
            if length(parsed_line) == 4
                # T: <action> : <start-state> : <next-state>

                temp_str = string.(split(parsed_line[4]))
                parsed_line[4] = ""
                parsed_line = filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cars = count(x -> isequal(x, "*"), parsed_line)


                if number_wild_cars == 0 
                    turn_into_number!(parsed_line, name_of_states, name_of_actions, [2,3,4], 4) 
                    # print(parsed_line, "\n\n")
                    nn_parsed_line = (parse(Int64, parsed_line[3]), parse(Int64, parsed_line[2]), parse(Int64, parsed_line[4])) 
                    if length(parsed_line) == 5
                        trans_prob[nn_parsed_line] = parse(Float64, parsed_line[5])
                    else
                        trans_prob[nn_parsed_line] = 1
                    end

                elseif number_wild_cars == 1
                    pos_wild = findfirst(x -> isequal(x, "*"), parsed_line)

                    if pos_wild == 2 # Wild card in the action place
                        turn_into_number!(parsed_line, name_of_states, name_of_actions, [3,4] , 4)

                        current_state = parse(Int64, parsed_line[3])
                        next_state = parse(Int64, parsed_line[4])

                        prob = parse(Float64, parsed_line[5])

                        nn_parsed_line = [(current_state, input, next_state) for input in 1:number_of_actions]


                        for tuple in nn_parsed_line
                            trans_prob[tuple] = prob
                        end
                    
                    elseif pos_wild == 3 # Wild card in the state place
                        turn_into_number!(parsed_line, name_of_states, name_of_actions, [2,4], 4)
                        # print(parsed_line, "\n\n")

                        input = parse(Int64, parsed_line[2])
                        next_state = parse(Int64, parsed_line[4])

                        if length(parsed_line) == 5
                            prob = parse(Float64, parsed_line[5])
                        else
                            prob = 1
                        end

                        # prob = parse(Float64, parsed_line[5])

                        nn_parsed_line = [(current_state, input, next_state) for current_state in 1:number_of_states]
                        
                        for tuple in nn_parsed_line
                            trans_prob[tuple] = prob
                        end

                    elseif pos_wild == 4 # Wild card in the next state place
                        turn_into_number!(parsed_line, name_of_states, name_of_actions, [2,3], 4)

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3])

                        @warn "I am modifying the value of next states to $(1/number_of_states)"
                        
                        prob = 1/number_of_states

                        nn_parsed_line = [(current_state, input, next_state) for next_state in 1:number_of_states]
                        
                        for tuple in nn_parsed_line
                            trans_prob[tuple] = prob
                        end
                    else
                        error("BLABLA")
                    end
                else
                    error("You cannot have two wild cards in the same row")
                end
            elseif length(parsed_line) == 3
                # T: <action> : <start-state>
                # print(split(parsed_line[3]))

                checking_third_param = split(parsed_line[3], " ", limit=2)

                if length(checking_third_param) == 1 # The transition probability will be on the next line
                    number_wild_cards = count(x -> isequal(x, "*"), parsed_line)
                    
                    if number_wild_cards == 0 
                        turn_into_number!(parsed_line, name_of_states, name_of_actions, [2,3], 4) # I may have to chande this function. Last parameter may not be needed
            
                        input = parse(Int64, parsed_line[2]) 
                        current_state = parse(Int64, parsed_line[3])

                        get_transition_prob_next_line!(current_state, input, trans_prob, index, number_of_states, trans_prob_occurences)
                    elseif number_wild_cards == 1
                        
                        if isequal(parsed_line[2], "*")
                            turn_into_number!(parsed_line, name_of_states, name_of_actions, [3], 4)

                            current_state = parse(Int64, parsed_line[3])

                            for input in 1:number_of_actions
                                get_transition_prob_next_line!(current_state, input, trans_prob, index, number_of_states, trans_prob_occurences)
                            end
                        elseif isequal(parsed_line[3], "*")
                            turn_into_number!(parsed_line, name_of_states, name_of_actions, [2], 4)

                            input = parse(Int64, parsed_line[2]) 

                            for current_state in 1:number_of_states
                                get_transition_prob_next_line!(current_state, input, trans_prob, index, number_of_states, trans_prob_occurences)
                            end
                        else
                            error("BLABLA")
                        end
                    elseif number_wild_cards == 2
                        for current_state in 1:number_of_states, input in 1:number_of_actions
                            get_transition_prob_next_line!(current_state, input, trans_prob, index, number_of_states, trans_prob_occurences) 
                        end
                    else
                        print("TBI: cannot parse this line")
                        # error("Not implemented")
                    end
                else # the transition probability will be given in the same line
                    parsed_line[3] = ""
                    parsed_line = filter(x -> !isempty(x), parsed_line)
                    map(x -> push!(parsed_line,x), checking_third_param)

                    number_wild_cards = count(x -> isequal(x, "*"), parsed_line)
                    
                    prob = strip(parsed_line[4]) |> split
                    print(number_wild_cards, "\n\n")

                    if number_wild_cards == 0
                        turn_into_number!(parsed_line, name_of_states, name_of_actions, [2,3], 4)

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3])

                        get_transition_prob_number_same_line!(current_state, input, prob, trans_prob, number_of_states)

                    elseif number_wild_cards == 1
                        if isequal(parsed_line[2], "*")
                            # print(parsed_line, "\n\n")
                            turn_into_number!(parsed_line, name_of_states, name_of_actions, [3], 4)

                            current_state = parse(Int64, parsed_line[3])

                            for input in 1:number_of_actions
                                get_transition_prob_number_same_line!(current_state, input, prob, trans_prob, number_of_states)
                            end

                        elseif isequal(parsed_line[3], "*")
                            turn_into_number!(parsed_line, name_of_states, name_of_actions, [2], 4)

                            input = parse(Int64, parsed_line[2])

                            for current_state in 1:number_of_states
                                get_transition_prob_number_same_line!(current_state, input, prob, trans_prob, number_of_states)
                            end
                        else
                            error("BLABLA")
                        end

                    elseif number_wild_cards == 2
                        for current_state = 1:number_of_states, input in 1:number_of_actions
                            get_transition_prob_number_same_line!(current_state, input, prob, trans_prob, number_of_states)
                        end
                    else
                        print("TBI: transition_prob. Number of wild cards not implemented")
                    end
                    
                end

            elseif length(parsed_line) == 2 # NEED TO ADD WILD CARDS HERE
                # Need to check whether it is a matrix, identity, or uniform
                if (index + 1) > length(trans_prob_occurences)
                    error("BLABLA")
                end

                next_line = trans_prob_occurences[index + 1] |> strip

                turn_into_number!(parsed_line, name_of_states, name_of_actions, [2], 4)
                input = parse(Int64, parsed_line[2])
                
                if isequal(next_line, "uniform")
                    prob_val = 1/number_of_states

                    for current_state in 1:number_of_states
                        for next_state in 1:number_of_states 
                            trans_prob[(current_state, input, next_state)] = prob_val
                        end
                    end
                elseif isequal(next_line, "identity")
                    prob_val = 1
                    
                    for current_state in 1:number_of_states
                        trans_prob[(current_state, input, current_state)] = prob_val
                    end
                else
                    if index + number_of_states > length(trans_prob_occurences)
                        error("BLABLA")
                    end

                    matrix_lines = trans_prob_occurences[index + 1:index + number_of_states]


                    if all(x -> !isnothing(tryparse.(Float64, split(x))), matrix_lines)
                        matrix_trans = hcat([parse.(Float64, split(row)) for row in matrix_lines]...)' 

                        for current_state in 1:number_of_states
                            for next_state in 1:number_of_states 
                                trans_prob[(current_state, input, next_state)] = matrix_trans[current_state, next_state]
                            end
                        end
                    else
                        error("BLABLA")
                    end
                end

            else
                error("BLABLA")
            end
                
        end
    end

    return trans_prob 
end

################ Auxiliary functions -- Observation probability ################## 

                    # Input: files_obs, number_of_states, number_of_actions, number_of_observations, parsed_line
function get_observation_matrix!(obs_prob::Any, parsed_line::Any, index::Int64, number_of_states::Int64, number_of_observations::Int64, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_observations::Dict{String,Int64}, files_obs::Vector{String})
    # Need to check whether it is a matrix, identity, or uniform
    if (index + 1) > length(files_obs)
        error("BLABLA")
    end

    next_line = files_obs[index + 1] |> strip

    turn_into_number_obs!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2])
    input = parse(Int64, parsed_line[2])
    
    if isequal(next_line, "uniform")
        prob_val = 1/number_of_observations

        for current_state in 1:number_of_states
            for obs in 1:number_of_observations 
                obs_prob[(current_state, input, obs)] = prob_val
            end
        end
    else
        if index + number_of_states > length(files_obs)
            error("BLABLA")
        end

        matrix_lines = files_obs[index + 1:index + number_of_states]


        if all(x -> !isnothing(tryparse.(Float64, split(x))), matrix_lines)
            matrix_obs = hcat([parse.(Float64, split(row)) for row in matrix_lines]...)' 

            for current_state in 1:number_of_states
                for obs in 1:number_of_observations 
                    obs_prob[(current_state, input, obs)] = matrix_obs[current_state, obs]
                end
            end
        else
            error("BLABLA")
        end
    end
end

function turn_into_number_obs!(parsed_line::Vector{String}, name_of_states::Dict{String, Int64}, name_of_actions::Dict{String, Int64}, name_of_obs::Dict{String, Int64}, indices::Vector{Int64})

    # the index parameter serves to select whether or not the entry is allowed to be substituted. This is essential to deal with the wild card

    if !isempty(name_of_states)
        if 3 in indices
            parsed_line[3] = string(name_of_states[parsed_line[3]])  
        end
    end

    if !isempty(name_of_obs)
        if 4 in indices
            parsed_line[4] = string(name_of_obs[parsed_line[4]]) 
        end
    end

    if !isempty(name_of_actions)
        if 2 in indices
            parsed_line[2] = string(name_of_actions[parsed_line[2]])
        end
    end
end


function processing_observations_probability(number_of_states::Int64, number_of_actions::Int64, number_of_observations::Int64, name_of_states::Dict{String,Int64}, name_of_actions::Dict{String,Int64}, name_of_observations::Dict{String, Int64}, files_obs::Vector{String})

    obs_prob = Dict((states, actions, observations) => 0. for states in 1:number_of_states, actions in 1:number_of_actions, observations in 1:number_of_observations)


    for (index, lines) in enumerate(files_obs)

        # print(lines, "\n\n")

        if isequal(get_before_semicolon(lines) |> strip, "O")
            parsed_line = string.(strip.(split(lines, ':')))
        
            # parsed = turn_into_number(parsed_line, name_of_states, name_of_actions) 
            if length(parsed_line) == 4
                # T: <action> : <start-state> : <next-state>

                temp_str = string.(split(parsed_line[4]))
                parsed_line[4] = ""
                parsed_line = filter(x->!isempty(x), parsed_line)
                map(x->push!(parsed_line, x), temp_str)

                number_wild_cars = count(x -> isequal(x, "*"), parsed_line)


                if number_wild_cars == 0 
                    turn_into_number_obs!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3,4]) 
                    nn_parsed_line = (parse(Int64, parsed_line[3]), parse(Int64, parsed_line[2]), parse(Int64, parsed_line[4])) 
                    if length(parsed_line) == 5
                        prob = parse(Float64, parsed_line[5])
                    else
                        prob = 1
                    end
                    obs_prob[nn_parsed_line] = prob 
                elseif number_wild_cars == 1
                    pos_wild = findfirst(x -> isequal(x, "*"), parsed_line)

                    if pos_wild == 2 # Wild card in the action place
                        turn_into_number_obs!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3,4])

                        current_state = parse(Int64, parsed_line[3])
                        obs = parse(Int64, parsed_line[4])
                        if length(parsed_line) == 5
                             prob = parse(Float64, parsed_line[5])
                        else
                            prob = 1
                        end

                        nn_parsed_line = [(current_state, input, obs) for input in 1:number_of_actions]


                        for tuple in nn_parsed_line
                            obs_prob[tuple] = prob
                        end
                    
                    elseif pos_wild == 3 # Wild card in the state place
                        turn_into_number_obs!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,4])

                        input = parse(Int64, parsed_line[2])
                        obs = parse(Int64, parsed_line[4])
                        
                        if length(parsed_line) == 5
                             prob = parse(Float64, parsed_line[5])
                        else
                            prob = 1
                        end

                        nn_parsed_line = [(current_state, input, obs) for current_state in 1:number_of_states]
                        
                        for tuple in nn_parsed_line
                            obs_prob[tuple] = prob
                        end

                    elseif pos_wild == 4 # Wild card in the next state place
                        turn_into_number_obs!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3])

                        input = parse(Int64, parsed_line[2])
                        current_state = parse(Int64, parsed_line[3])

                        @warn "I am modifying the value of next states to $(1/number_of_observations)"
                        
                        prob = 1/number_of_observations

                        nn_parsed_line = [(current_state, input, obs) for obs in 1:number_of_observations]
                        
                        for tuple in nn_parsed_line
                            obs_prob[tuple] = prob
                        end
                    else
                        error("BLABLA")
                    end
                else
                    print("TBI: two wild cards, processing_observation_probability \n\n")
                    # error("You cannot have two wild cards in the same row")
                end
            elseif length(parsed_line) == 3
                # O: <action> : <start-state>
                
                checking_third_param = split(parsed_line[3], " ", limit=2)
                
                if length(checking_third_param) == 1 # the transition probability will be on next line

                    number_wild_cards = count(x -> isequal(x, "*"), parsed_line)

                    if number_wild_cards == 0
                    next_line =  string.(split(files_obs[index + 1])) 
                    if all(x -> !isnothing(tryparse(Float64, x)), next_line)
                        prob = map(x -> parse(Float64, x), next_line)

                        if testing_if_probability(prob) && (length(prob) == number_of_observations) 

                            turn_into_number_obs!(parsed_line, name_of_states, name_of_actions, name_of_observations, [2,3])
                            # turn_into_number!(parsed_line, name_of_states, name_of_actions, [2, 3], 4) # I may have to chande this function. Last parameter may not be needed
                            
                            input = parse(Int64, parsed_line[2]) 
                            current_state = parse(Int64, parsed_line[3])

                            for (i, value_prob) in enumerate(prob)
                                obs_prob[(current_state, input, i)] = value_prob 
                            end
                            # NEED TO CONTINUE FROM HERE. MISSING POINTS:
                            # 1. CHECK WHETHER * CAN APPEAR HERE
                            # 2. ADD IDENTITY AND UNIFORM SETTING
                        else
                            error("BLABLA")
                        end
                    else
                        error("BLABLA")
                    end
                    elseif number_wild_cards == 1 # Only implemented * on the first entry. Need to finish the rest
                        next_line =  string.(split(files_obs[index + 1])) 
                        if all(x-> !isnothing(tryparse(Float64, x)), next_line)
                            prob = map(x -> parse(Float64, x), next_line)

                            if testing_if_probability(prob) && (length(prob) == number_of_observations)
                                turn_into_number_obs!(parsed_line, name_of_states, name_of_actions, name_of_observations, [3])
                                # turn_into_number!(parsed_line, name_of_states, name_of_actions, [2, 3], 4) # I may have to chande this function. Last parameter may not be needed
                                
                                current_state = parse(Int64, parsed_line[3])

                                for input in 1:number_of_actions
                                    for (i, value_prob) in enumerate(prob)
                                        obs_prob[(current_state, input, i)] = value_prob 
                                    end
                                end
                            else
                                error("BLABLA")
                            end
                        else
                            error("BLABLA")
                        end
                    else
                        print("TBI: two wild cards not implemented in processing_observations_probability \n\n")
                        # error("Not implemented")
                    end
                else
                    # print(parsed_line, "\n\n")
                    parsed_line[3] = ""
                    parsed_line = filter(x -> !isempty(x), parsed_line)
                    map(x -> push!(parsed_line,x), checking_third_param)
                    # print(parsed_line, "\n\n")
                    turn_into_number!(parsed_line, name_of_states, name_of_actions, [2,3], 4)
                    # print(parsed_line, "\n\n")

                    input = parse(Int64, parsed_line[2])
                    current_state = parse(Int64, parsed_line[3])

                    prob = strip(parsed_line[4]) |> split

                    if all(map(x -> !isnothing(tryparse(Float64,x)), prob)) && (length(prob) == number_of_observations)
                        prob = map(x->parse(Float64, x), prob)
                        # print(prob, "\n\n")
                        if testing_if_probability(prob)
                            for (index, obs) in enumerate(1:number_of_observations)
                                obs_prob[(current_state,input,obs)] = prob[index]
                            end
                        else
                            error("BLABLA")
                        end
                    else
                        error("BLABLA")
                    end
                end

                
                    # print("$(next_line) \n")
                

            elseif length(parsed_line) == 2
             # o: <actions> : matrix
             # O: * : matrix with the obersation trans_prob for every action

                number_wild_cards = count(x-> isequal(x, "*"), parsed_line)

                if number_wild_cards == 0
                    # Input: files_obs, number_of_states, number_of_actions, number_of_observations, parsed_line
                    get_observation_matrix!(obs_prob, parsed_line, index, number_of_states, number_of_observations, name_of_states, name_of_actions, name_of_observations, files_obs)

                elseif number_wild_cards == 1

                    for input in keys(name_of_actions)
                        # print(input, "\n\n")
                        parsed_line[2] = input
                        # print(parsed_line, "\n\n")
                        # print(name_of_actions, "\n\n")
                        get_observation_matrix!(obs_prob, parsed_line, index, number_of_states, number_of_observations, name_of_states, name_of_actions, name_of_observations, files_obs)
                    end
                #    print("TBI: transition_obs_probability function. Here \n\n")
                else
                    error("BLABLA")
                end
            else
                print("TBI: transition_obs_probability\n\n")
                # error("BLABLA")
            end
                
        end
    end

    return obs_prob 
end