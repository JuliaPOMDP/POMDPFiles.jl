const REGEX_FLOATING_POINT = r"[-+]?[0-9]*\.?[0-9]+"
using LinearAlgebra

"""
    Read a `.alpha` file as generated by pomdp-solve.
    Works the same was as `read_pomdp` in `POMDPXFile.jl`.

    The `.alpha` file format is recapped here as follows,
    see: http://www.pomdp.org/code/alpha-file-spec.html

    A set of vectors is the representation use for the value function and each
    vector has an action associated with it. The vectors represent the coefficients
    of a hyperplane passing through the origin. The format specified here is what is
    output from the 'pomdp-solve' program and what will be necessary for input to
    the 'pomdp-solve' program with the '-terminal_values' command line option.

    The format is simply:

    A
    V1 V2 V3 ... VN

    A
    V1 V2 V3 ... VN

    ...


    Where `A` is an action number and the `V1` through `VN` are real values
    representing the components of a particular vector that has the associated
    action. The action number is the 0-based index of the action as specificed in
    the input POMDP file. The vector represents the coefficients of a hyperplane
    representing one facet of the piecewise linear and convex value function.
    Note that the length of the lists needs to be equal to the number of states in
    the POMDP.

    To find which action is the "best" for a given set of alpha vectors, the belief
    state probabilities would be used in a dot product against each alpha vectors'
    coefficients. The action associated with the vector with the highest value is
    the best action to take for that belief state given the value function.
"""
function read_alpha(filename::AbstractString)
    lines = open(readlines, filename)

    alpha_vector_line_indeces = Int[]
    vector_length = -1

    for i in 1:length(lines)

        matches = collect((m.match for m = eachmatch(REGEX_FLOATING_POINT, lines[i])))

        if length(matches) > 1
            push!(alpha_vector_line_indeces, i)
            @assert occursin(r"^(\d)*$", lines[i-1]) "previous line must contain an action index"

            if vector_length == -1
                vector_length = length(matches)
            else
                @assert vector_length == length(matches) "vector length is inconsistent. Was $vector_length, is $(length(matches)) on line $i"
            end
        end
    end
    num_alpha_vectors = length(alpha_vector_line_indeces)

    # Initialize the Γ matrix.
    # The α-vectors are the columns
    alpha_vectors = Array{Float64}(undef, vector_length, num_alpha_vectors)

    # Initialize the alpha_actions vector
    # alpha_actions[i] is the index of the action associated with
    # the alpha-vector in the ith column of alpha_vectors
    # Note that these are 0-indexed
    alpha_actions = Array{Int}(undef, num_alpha_vectors)

    for (i,line_index) in enumerate(alpha_vector_line_indeces)
        alpha_actions[i] = parse(Int, lines[line_index-1])

        for (j,match) in enumerate(eachmatch(REGEX_FLOATING_POINT, lines[line_index]))
            alpha_vectors[j,i] = parse(Float64, match.match)
        end
    end

    return alpha_vectors, alpha_actions
end

function read_pomdp(filename::AbstractString)
    lines = open(readlines, filename)

    discount = 0
    num_states = 0
    num_actions = 0
    num_observations = 0

    states = 0
    actions = 0
    observations = 0

    T_lines = Vector{Int64}()
    O_lines = Vector{Int64}()
    R_lines = Vector{Int64}()

    lines = map(lines) do line
        line[1:something(findfirst('#', line), length(line))]
    end

    for i in 1:length(lines)
        if length(lines[i]) > 0
            if occursin(r"discount:", lines[i]) && lines[i][1] != '#'
                discount = parse(Float64, match(REGEX_FLOATING_POINT, lines[i]).match)
            end
            if occursin(r"states:", lines[i]) && lines[i][1] != '#'
                states = split(strip(lines[i]), ' ')
                if length(states) > 2
                    num_states = length(states) - 1
                    states = states[2:end]
                else
                    num_states = parse(Int64, states[2])
                    states = collect(string(i) for i in 0:num_states-1)
                end
            end
            if occursin(r"actions:", lines[i]) && lines[i][1] != '#'
                actions = split(strip(lines[i]), ' ')
                if length(actions) > 2
                    num_actions = length(actions) - 1
                    actions = actions[2:end]
                else
                    num_actions = parse(Int64, actions[2])
                    actions = collect(string(i) for i in 0:num_actions-1)
                end
            end
            if occursin(r"observations:", lines[i]) && lines[i][1] != '#'
                observations = split(strip(lines[i]), ' ')
                if length(observations) > 2
                    num_observations = length(observations) - 1
                    observations = observations[2:end]
                else
                    num_observations = parse(Int64, observations[2])
                    observations = collect(string(i) for i in 0:num_observations-1)
                end
            end
            if occursin(r"T:|T :", lines[i])
                push!(T_lines, i)
            end
            if occursin(r"O:|O :", lines[i])
                push!(O_lines, i)
            end
            if occursin(r"R:|R :", lines[i])
                push!(R_lines, i)
            end
        end
    end

    init_state_lines = get_all_occurences(lines, ["start", "start include", "start exclude"])
    ss_dic = Dict{String, Int64}(nn => index for (index, nn) in enumerate(string.(states)))

    if !isa(init_state_lines, Vector{Nothing})

        init_state_lines_f = filter(x -> !isnothing(x), init_state_lines)
        init_state_info = processing_initial_distribution(num_states, ss_dic, lines[sort(init_state_lines_f)])
    end

    T = zeros(num_states, num_actions, num_states)
    O = zeros(num_observations, num_actions, num_states)
    R = zeros(num_states, num_actions)

    ind1 = 0
    ind2 = 0
    ind3 = 0

    if length(T_lines) > 0
        if length(findall(x->x==':', lines[T_lines[1]])) == 3
            for t in T_lines
                l = replace(lines[t], ':'=>' ')
                line = split(l, ' ')
                line = collect(strip(i) for i in line)
                deleteat!(line, findall(x->x=="", line))
                if line[3] == "*"
                    ind1 = collect(1:length(states))
                else
                    ind1 = findall(x->x==line[3], states)
                end
                if line[2] == "*"
                    ind2 = collect(1:length(actions))
                else
                    ind2 = findall(x->x==line[2], actions)
                end
                if line[4] == "*"
                    ind3 = collect(1:length(states))
                else
                    ind3 = findall(x->x==line[4], states)
                end
                T[ind3, ind2, ind1] .= parse(Float64, line[5])
            end
        elseif length(findall(x->x==':', lines[T_lines[1]])) == 2
            for t in T_lines
                l = t+1
                act = strip(split(lines[t], ':')[2])
                st = strip(split(lines[t], ':')[3])
                i = findfirst(x->x==act, actions)
                j = findfirst(x->x==st, states)
                T[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
            end
        else
            for t in T_lines
                l = t+1
                id = findall(strip(lines[l]), "identity")
                un = findall(strip(lines[l]), "uniform")
                act = strip(split(lines[t], ':')[2])
                i = findfirst(x->x==act, actions)
                if length(id) > 0
                    for j in 1:num_states
                        T[j,i,j] = 1
                        l += 1
                    end
                elseif length(un) > 0
                    for j in 1:num_states
                        T[:,i,j] = ones(num_states)./num_states
                        l += 1
                    end
                else
                    for j in 1:num_states
                        T[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
                        l += 1
                    end
                end
            end
        end
    end

    if length(O_lines) > 0
        if length(findall(x->x==':', lines[O_lines[1]])) == 3
            for t in O_lines
                l = replace(lines[t], ':'=>' ')
                line = split(l, ' ')
                line = collect(strip(i) for i in line)
                deleteat!(line, findall(x->x=="", line))
                if line[4] == "*"
                    ind1 = collect(1:length(observations))
                else
                    ind1 = findall(x->x==line[4], observations)
                end
                if line[2] == "*"
                    ind2 = collect(1:length(actions))
                else
                    ind2 = findall(x->x==line[2], actions)
                end
                if line[3] == "*"
                    ind3 = collect(1:length(states))
                else
                    ind3 = findall(x->x==line[3], states)
                end
                O[ind1, ind2, ind3] .= parse(Float64, line[5])
            end
        elseif length(findall(x->x==':', lines[O_lines[1]])) == 2
            for t in T_lines
                l = t+1
                act = strip(split(lines[t], ':')[2])
                st = strip(split(lines[t], ':')[3])
                i = findfirst(x->x==act, actions)
                j = findfirst(x->x==st, states)
                O[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
            end
        else
            for t in O_lines
                l = t+1
                un = findall(strip(lines[l]), "uniform")
                act = strip(split(lines[t], ':')[2])
                if act == "*"
                    if length(un) > 0
                        for j in 1:num_states
                            for i in 1:num_actions
                                O[:,i,j] = ones(num_observations)./num_observations
                            end
                            l += 1
                        end
                    else
                        for j in 1:num_states
                            for i in 1:num_actions
                                O[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
                            end
                            l += 1
                        end
                    end
                else
                    i = findfirst(x->x==act, actions)
                    if length(un) > 0
                        for j in 1:num_states
                            O[:,i,j] = ones(num_observations)./num_observations
                            l += 1
                        end
                    else
                        for j in 1:num_states
                            O[:,i,j] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
                            l += 1
                        end
                    end
                end
            end
        end
    end

    if length(R_lines) > 0
        if length(findall(x->x==':', lines[R_lines[1]])) == 4
            for t in R_lines
                l = replace(lines[t], ':'=>' ')
                line = split(l, ' ')
                line = collect(strip(i) for i in line)
                deleteat!(line, findall(x->x=="", line))
                if line[3] == "*"
                    ind1 = collect(1:length(states))
                else
                    ind1 = findall(x->x==line[3], states)
                end
                if line[2] == "*"
                    ind2 = collect(1:length(actions))
                else
                    ind2 = findall(x->x==line[2], actions)
                end
                R[ind1, ind2] .= parse(Float64, line[6])
            end
        elseif length(findall(x->x==':', lines[R_lines[1]])) == 3
            for t in R_lines
                l = t+1
                act = strip(split(lines[t], ':')[2])
                i = findfirst(x->x==act, actions)
                for j in 1:num_states
                    T[j,i,:] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
                    l += 1
                end
            end
        else
            for t in R_lines
                l = t+1
                act = strip(split(lines[t], ':')[2])
                i = findfirst(x->x==act, actions)
                for j in 1:num_states
                    T[j,i,:] = collect((parse(Float64, m.match) for m = eachmatch(REGEX_FLOATING_POINT, lines[l])))
                    l += 1
                end
            end
        end
    end

    m = TabularPOMDP(T, R, O, discount)
    return m
end



# Functions dealing with the initial distribution

######## GETTING THE LINES FOR AN OCCURENCE OF A STRING IN THE FILE ##################

function get_all_occurences(source_file::Vector{String}, starting_line::Int64, key::String)

    removed_text = source_file[starting_line:end]
    all_occurences = findall(x -> isequal(get_before_semicolon(x), key), removed_text) 
   
    return isempty(all_occurences) ? nothing : all_occurences 
end

get_all_occurences(source_file::Vector{String}, key::String) = get_all_occurences(source_file, 1, key)
get_all_occurences(source_file::Vector{String}, multiple_keys::Vector{String}) = reduce(vcat, map(x -> get_all_occurences(source_file, x), multiple_keys))

get_first_occurence(source_file::Vector{String}, starting_line::Int64, key::String) = !isnothing(get_all_occurences(source_file, starting_line, key)) ? minimum(get_all_occurences(source_file, starting_line, key) .-1 .+starting_line) : nothing
get_first_occurence(source_file::Vector{String}, key::String) = get_first_occurence(source_file, 1, key) 

get_last_occurence(source_file::Vector{String}, starting_line::Int64, key::String) = !isnothing(get_all_occurences(source_file, starting_line, key)) ? maximum(get_all_occurences(source_file, starting_line, key) .-1 .+starting_line) : nothing
get_last_occurence(source_file::Vector{String}, key::String) = get_last_occurence(source_file, 1, key) 

struct InitialStateParam{T}

    size_of_states::T
    type_of_distribution::String
    support_of_distribution::Set{T}
    value_of_distribution::Vector{Float64}

    function InitialStateParam{T}(size_of_states::T, type_of_distribution::String, support_of_distribution::Set{T}, 
                            value_of_distribution::Vector{Float64}) where T<:Int64 

                            # print(value_of_distribution)
                            # print("\n")
        # Length of value_of_distribution must coincide with N, and all elements of support_of_distribution must be smaller, or equal to, N

        if isempty(type_of_distribution) 
            new{T}(size_of_states, "", Set{Int64}([]), Vector{Float64}([]))
        elseif (length(value_of_distribution) != size_of_states) || (collect(support_of_distribution) |> maximum) > size_of_states
            error("BLABLA")
        elseif !isapprox(sum(value_of_distribution),1) || any(x -> (x > 1) || (x < 0),  value_of_distribution) # checking whether value_of_distribution is a valid probability distribution
            error("BLABLA")
        else
            new{T}(size_of_states, type_of_distribution, support_of_distribution, value_of_distribution)
        end
    end
end

InitialStateParam() = InitialStateParam{Int64}(0, "", Set{Int64}([]), Vector{Float64}([])) 
InitialStateParam(size_of_states::Int64) = InitialStateParam{Int64}(size_of_states, "", Set{Int64}([]), Vector{Float64}([])) 

function read_ordinal_file(file_name::String; state_size = 20)
    
    ordinal_names = open(readlines, file_name)[1:state_size]
    ordinal_names = map(x -> replace(get_after_semicolon(x), r"[\s+]" => ""), ordinal_names)

    return Dict([ordinal_names[i] => i for i in 1:state_size])
    
end

function get_before_semicolon(line::String)
    regex_before_semicolon = r"([^:]*):"

    search_pattern = match(regex_before_semicolon, line)
    return !isnothing(search_pattern) ? replace(search_pattern.match, r":+" => "") : "none-found"
end

function get_after_semicolon(line::String)
    regex_after_semicolon = r":(.)*$"

    search_pattern = match(regex_after_semicolon, line)
    return !isnothing(search_pattern) ? replace(search_pattern.match, r":+" => "") : "none-found"
end

function dealing_with_partial_numbers(ordinal_dictionary::Dict{String, Int64}, initial_state_param::String)

    init_state = split(initial_state_param)
    state_size = length(ordinal_dictionary)

    if all(x -> x in keys(ordinal_dictionary), init_state)

        support_of_distribution = Set{Int64}([ordinal_dictionary[key] for key in init_state])  
        temp = [ordinal_dictionary[key] for key in init_state]
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,temp], dims=2)

        return support_of_distribution, value_of_distribution
    elseif all(x -> tryparse(Int64, x) in values(ordinal_dictionary), init_state)

        init_state = map(x -> parse(Int64, x), init_state)
        # print(init_state)
        # print("\n")
        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,init_state], dims=2)

        return support_of_distribution, value_of_distribution

    else
        return nothing, nothing
    end
end

function processing_initial_distribution_start(state_size::Int64, after_semicolon::String, name_of_states::Dict{String, Int64})

    aux_var = tryparse(Int64, after_semicolon)

    if !isnothing(aux_var) # testing whether is a number

        if aux_var > state_size
            error("BLABLA")
        end

        value_of_distribution = Diagonal(ones(Float64, state_size))[:,aux_var]
        support_of_distribution = Set{Int64}(aux_var) 
        return InitialStateParam{Int64}(state_size, "dirac", support_of_distribution, value_of_distribution) 
        
    elseif all(x -> isa(x, Float64) && (x<=1) && (x>=0) , map(x->tryparse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_semicolon))) # testing whether s₀_param is a probability vector

        value_of_distribution =  map(x->parse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_semicolon))
        support_of_distribution =  Set(findall(x -> x > 0, value_of_distribution))
        return InitialStateParam{Int64}(state_size, "general distribution", support_of_distribution, value_of_distribution) 

    elseif isequal(replace(after_semicolon, r"[\"+]|[\s+]" => ""), "uniform") # testing initial state is uniform 

        value_of_distribution = (1/state_size)*ones(state_size)
        support_of_distribution = Set{Int64}([i for i in Base.OneTo(state_size)])

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution)

    elseif all(x -> x in keys(name_of_states), split(after_semicolon))

        init_state = map(x -> name_of_states[x], split(after_semicolon))

        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)
        
        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        

        ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 
        support_of_distribution, value_of_distribution = dealing_with_partial_numbers(ordinal_dictionary, after_semicolon)

        if !isnothing(support_of_distribution) 
            return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
        else
            error("BLABLA")
        end
    end


end

function processing_initial_distribution_start_include(state_initial_param::InitialStateParam, after_semicolon::String, name_of_states::Dict{String, Int64})

    init_state = split(after_semicolon)
    state_size = state_initial_param.size_of_states
    
    ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 


    if all(x -> tryparse(Int64, x) in 1:state_size, init_state) 

        adding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    elseif all(x -> x in keys(ordinal_dictionary), init_state)

        init_state = map(x -> ordinal_dictionary[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    elseif all(x -> x in keys(name_of_states), init_state)

        init_state = map(x -> name_of_states[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    else
        error("BLABLA")
    end

    # jk
    return

end

function processing_initial_distribution_start_exclude(state_initial_param::InitialStateParam, after_semicolon::String, name_of_states::Dict{String, Int64})

    init_state = split(after_semicolon)
    state_size = state_initial_param.size_of_states
    
    ordinal_dictionary = read_ordinal_file("initial-state.txt"; state_size) 

    if all(x -> isa(tryparse(Int64, x), Int64), init_state) 

        excluding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    elseif all(x -> x in keys(ordinal_dictionary), init_state)

        init_state = map(x -> ordinal_dictionary[x], init_state)
        excluding_set = Set{Int64}(init_state)
        
        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)    

    elseif all(x -> x in keys(name_of_states), init_state)


        init_state = map(x -> name_of_states[x], init_state)
        excluding_set = Set{Int64}(init_state)

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    else
        print("To be implemented")
    end
    
    return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
end

function processing_initial_distribution(number_of_states::Int64, name_of_states::Dict{String, Int64}, initial_state_ocurrences::Vector{String})
    # According to the grammar this can either be a number, a probability distribution over states, or strings (uniform or ordinal description of states)
    # print(s₀_param)
    initial_state_param = InitialStateParam(number_of_states)
    
    for line in initial_state_ocurrences

        type_init_state = get_before_semicolon(line)

        if isequal(type_init_state, "start")
            
            param_init = get_after_semicolon(line)
            initial_state_param = processing_initial_distribution_start(number_of_states, param_init, name_of_states)

        elseif isequal(type_init_state, "start include")

            param_init = get_after_semicolon(line)
            initial_state_param = processing_initial_distribution_start_include(initial_state_param, param_init, name_of_states)
            
        elseif isequal(type_init_state, "start exclude")

            param_init = get_after_semicolon(line)
            initial_state_param = processing_initial_distribution_start_exclude(initial_state_param, param_init, name_of_states)
        else
            error("BLABLA")
        end
    end

    print(initial_state_param)
    print("\n")

    return initial_state_param

    # We will now process the include/exclude option. I THINK I NEED TO TURN THE PREVIOUS FUNCTION INTO AN AUXILIARY ONE
end
