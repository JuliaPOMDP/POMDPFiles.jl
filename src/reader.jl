const REGEX_FLOATING_POINT = r"[-+]?[0-9]*\.?[0-9]+"
"""
    Read a `.alpha` file as generated by pomdp-solve.
    Works the same was as `read_pomdp` in `POMDPXFile.jl`.

    The `.alpha` file format is recapped here as follows,
    see: http://www.pomdp.org/code/alpha-file-spec.html

    A set of vectors is the representation use for the value function and each
    vector has an action associated with it. The vectors represent the coefficients
    of a hyperplane passing through the origin. The format specified here is what is
    output from the 'pomdp-solve' program and what will be necessary for input to
    the 'pomdp-solve' program with the '-terminal_values' command line option.

    The format is simply:

    A
    V1 V2 V3 ... VN

    A
    V1 V2 V3 ... VN

    ...


    Where `A` is an action number and the `V1` through `VN` are real values
    representing the components of a particular vector that has the associated
    action. The action number is the 0-based index of the action as specificed in
    the input POMDP file. The vector represents the coefficients of a hyperplane
    representing one facet of the piecewise linear and convex value function.
    Note that the length of the lists needs to be equal to the number of states in
    the POMDP.

    To find which action is the "best" for a given set of alpha vectors, the belief
    state probabilities would be used in a dot product against each alpha vectors'
    coefficients. The action associated with the vector with the highest value is
    the best action to take for that belief state given the value function.
"""
function read_alpha(filename::AbstractString)
    lines = open(readlines, filename)

    alpha_vector_line_indeces = Int[]
    vector_length = -1

    for i in eachindex(lines)

        matches = collect((m.match for m = eachmatch(REGEX_FLOATING_POINT, lines[i])))

        if length(matches) > 1
            push!(alpha_vector_line_indeces, i)
            @assert occursin(r"^(\d)*$", lines[i-1]) "previous line must contain an action index"

            if vector_length == -1
                vector_length = length(matches)
            else
                @assert vector_length == length(matches) "vector length is inconsistent. Was $vector_length, is $(length(matches)) on line $i"
            end
        end
    end
    num_alpha_vectors = length(alpha_vector_line_indeces)

    # Initialize the Γ matrix.
    # The α-vectors are the columns
    alpha_vectors = Array{Float64}(undef, vector_length, num_alpha_vectors)

    # Initialize the alpha_actions vector
    # alpha_actions[i] is the index of the action associated with
    # the alpha-vector in the ith column of alpha_vectors
    # Note that these are 0-indexed
    alpha_actions = Array{Int}(undef, num_alpha_vectors)

    for (i,line_index) in enumerate(alpha_vector_line_indeces)
        alpha_actions[i] = parse(Int, lines[line_index-1])

        for (j,match) in enumerate(eachmatch(REGEX_FLOATING_POINT, lines[line_index]))
            alpha_vectors[j,i] = parse(Float64, match.match)
        end
    end

    return alpha_vectors, alpha_actions
end

function read_pomdp(filename::String; output::Symbol = :SFilePOMDP)
    lines = open(readlines, filename) |> remove_comments_and_white_space 

    # Getting info from preamble
    regex_filtering_preamble = r"\s*[RTO]\s*:"
    preamble = lines[1:findfirst(startswith.(lines, regex_filtering_preamble))-1]
    preamble_dict = check_preamble_fields(join(preamble, "\n"))
    discount, type_reward, actions, states, observations = process_preamble(preamble_dict)

    dic_action = Dict(string(nn) => index for (index, nn) in enumerate(names(actions)))
    dic_states = Dict(string(nn) => index for (index, nn) in enumerate(names(states)))
    dic_obs = Dict(string(nn) => index for (index, nn) in enumerate(names(observations)))

    # # # # Processing the initial distribution
    initialstate = InitialStateParam()
    if "start" in keys(preamble_dict)
        initialstate_content = preamble_dict["start"] 

        if isequal(initialstate_content, "uniform")
            initialstate.support_of_distribution = Set([i for i in Base.OneTo(number(states))])
            initialstate.value_of_distribution = (1/number(states))*ones(number(states))
            initialstate.type_of_distribution = "uniform"
            initialstate.number = number(states)

        else
            types = [Float64, Int]
            tmp_initialstate_content = map(x->tryparse.(x, string.(split(initialstate_content))), types)

            # Either a vector suming to one
            if all(x -> !isnothing(x), tmp_initialstate_content[1]) # or a vector of floats 
                @assert test_if_probability(tmp_initialstate_content[1]) 

                # Saving content on InitialStateParam
                initialstate.value_of_distribution = tmp_initialstate_content[1]
                initialstate.support_of_distribution = Set(findall(x -> x > 0, initialstate.value_of_distribution))
                initialstate.type_of_distribution = "general distribution"
                initialstate.number = number(states)    

            elseif all(x -> !isnothing(x), tmp_initialstate_content[2]) # or a vector of integers 
                @assert (all(x -> x >= 1 && x <= number(states), tmp_initialstate_content[2])) 

                # Saving content on InitialStateParam
                initialstate.support_of_distribution = Set(tmp_initialstate_content[2])
                initialstate.value_of_distribution = vec((1/length(initialstate.support_of_distribution))*sum(Diagonal(ones(Float64, number(states)))[:, collect(initialstate.support_of_distribution)], dims=2))
                initialstate.type_of_distribution = "uniform"
                initialstate.number = number(states)

            elseif all(x-> x in names(states), string.(split(initialstate_content))) # or a vector of names
                # Saving content on InitialStateParam
                init_state = map(x -> dic_states[x], string.(split(initialstate_content)))
                initialstate.support_of_distribution = Set(init_state)
                initialstate.value_of_distribution = vec((1/length(initialstate.support_of_distribution))*sum(Diagonal(ones(Float64, number(states)))[:, collect(initialstate.support_of_distribution)], dims=2))
                initialstate.type_of_distribution = "uniform"
                initialstate.number = number(states)

            else
                error("Unable to parse the initial condition.")
            end

        end
    end

    return discount, type_reward, actions, states, observations, preamble_dict, initialstate 

    # # # Processing the initial distribution
    # regex_start = r"\s*start\s*:"

    # # regex_init_cond = r"\s*start include\s*:|\s*start exclude\s*:|\s*start\s*:"
    # init_state_lines = findall(startswith.(preamble, regex_init_cond)) 
    # init_state_info = InitialStateParam()

    # if !isempty(preamble[init_state_lines])
    #     content = 
    #     init_state_info = process_initial_distribution(names(states), dic_states, preamble[init_state_lines])
    # end

    # # # Processing transition probability

    # sorted_fields = order_of_transition_reward_observation(lines, 1)

    # files_transition = []
    # files_obs = []
    # files_values = []

    # # Finding the chunk of the file with the transition, observation, and reward specifications
    # for (index, (type_of_matrix, line_number)) in enumerate(sorted_fields)
    #     if index  < length(sorted_fields)
    #         range_spec = line_number:(sorted_fields[index+1][2] -1)
    #         if isequal(type_of_matrix, "T")
    #             files_transition = lines[range_spec]
    #         end
    #         if isequal(type_of_matrix, "O")
    #             files_obs = lines[range_spec]
    #         end
    #         if isequal(type_of_matrix, "R")
    #             files_values = lines[range_spec]
    #         end
    #     else
    #         range_spec = (line_number:length(lines))
    #         if isequal(type_of_matrix, "T")
    #             files_transition = lines[range_spec]
    #         end
    #         if isequal(type_of_matrix, "O")
    #             files_obs = lines[range_spec]
    #         end
    #         if isequal(type_of_matrix, "R")
    #             files_values = lines[range_spec]
    #         end
    #     end
    # end

    # # Processing observation probability
    # str_trans = join(files_transition, "\n")
    # vv = [string.(names(actions)), string.(names(states)), string.(names(states))]
    # wc_trans = WildcardArrays.parse(str_trans, vv)

    # # Processing observation probability
    # str_obs = join(files_obs, "\n")
    # vv = [string.(names(actions)), string.(names(states)), string.(names(observations))]
    # wc_obs = WildcardArrays.parse(str_obs, vv)
    
    # # Processing observation probability
    # str_values = join(files_values, "\n")
    # vv = [string.(names(actions)), string.(names(states)), string.(names(states)), string.(names(observations))]
    # wc_values = WildcardArrays.parse(str_values, vv)
    
    # pomdp_struc = FilePOMDP(number(states), number(actions), number(observations), init_state_info, discount[1], wc_trans, wc_obs, wc_values)

    # if output == :FilePOMDP
    #     return pomdp_struc
    # elseif output == :SFilePOMDP
    #     return SFilePOMDP(dic_states, dic_action, dic_obs, pomdp_struc)
    # else
    #     error("Output type invalid")
    # end
end

################ Auxiliary functions ##################
function test_if_probability(prob::Union{Vector{Float64}, Vector{Nothing}, Nothing};rtol=1e-3)
    if isnothing(prob) || eltype(prob) == Nothing
        return false
    else
        between_0_1 = all(x -> 0 <= x <= 1, prob)
        return (between_0_1 && isapprox(sum(prob), 1; rtol=rtol)) ? true : false
    end
end

function remove_comments_and_white_space(file::Vector{String})
    processed_file = []

    for line in file
        without_comments = replace(line, r"#.*" => "") |> strip

        if !isempty(without_comments)
            push!(processed_file, without_comments)
        end
    end

    return Vector{String}(filter(x -> !isempty(x), processed_file))
end

function get_before_colon(line::String)
    regex_before_colon = r"([^:]*):"

    search_pattern = match(regex_before_colon, line)
    
    return !isnothing(search_pattern) ? replace(search_pattern.match, r":+" => "") : "none-found"
end

function get_after_colon(line::String)
    # println(length(line))
    if length(line) > 5000 # breaking in chunks of 5000
        number_chunks = div(length(line), 5000)
        # println(number_chunks)
        temp = "" 

        for ii in 1:number_chunks
            pre_process = ii < number_chunks ? _get_after_colon(line[(ii-1)*5000 + 1:ii*5000], ii) : _get_after_colon(line[((ii-1)*5000 +1):length(line)], ii)
            # println(pre_process)
            # println(typeof(pre_process))
            if !isequal(pre_process, "none-found")
                temp = temp*pre_process
            else
                error("Error while parsing the file.")
            end
        end
        return temp
    else
        return _get_after_colon(line, 1)    
    end
    
    @assert length(obs_prob_index) == length(obs_prob_values) "Error while constructing the transition probability. Keys and values must have the same size."
end

function _get_after_colon(line::String, ii::Int64)
    if ii == 1
        regex_after_colon = r":(.)*$"
        search_pattern = match(regex_after_colon, line)

        if !isnothing(search_pattern)
            return replace(search_pattern.match, r":+" => "")
        else
            return "none-found"
        end
    else
        return line
    end
end

function convert_to_data_structure(field::String, preamble::Dict{String,String}) 
    entry = preamble[field]
    entry = replace(entry, r"\"+" => "")

    return !isnothing(tryparse(Int64, entry)) ? parse(Int64, entry) : string.(split(entry))
end

function order_of_transition_reward_observation(file_lines::Vector{String}, start_line::Int64) 
    key_field = ["O", "T", "R"]
    regex_fields = Vector{String}()

    [push!(regex_fields, "\\s*$field\\s*:") for field in key_field]

    indices = map(x-> findfirst(startswith.(file_lines, Regex(x))), regex_fields)

    dict_scanning = Dict(field => indices[ii] for (ii, field) in enumerate(key_field)) 
    sorted_fields = sort(collect(pairs(dict_scanning)), by=x->x[2])

    return sorted_fields
end

######### Auxiliary functions -- PREAMBLE ###############

function check_preamble_fields(preamble::String)
    # I am assuming this function is going to work on a string that contains the preamble and the first line of non-preamble content, e.g.,
    # preamble = """
    # discount: 0.95\nvalues: reward\nstates: 11\nactions: N0 S0 E0 W0\nobservations: 7\nstart: 0.100000 0.100000 0.100000 0.100000 0.100000 0.100000 0.100000 0.100000 0.100000 0.100000 0.0 
    # T: 0 : 0 : 0 0.4586 
    # """ 

    key_fields = ["discount", "values", "states", "actions", "observations"]
    preamble_vec = string.(split(preamble, "\n"))

    preamble_dict = Dict{String, String}() 
    field_dict = Dict{String, Int64}()

    # Checking whether the preamble has all the necessary fields
    for field in key_fields
        reg_expr = Regex("\\s*$(field)\\s*:")
        index = findfirst(startswith.(preamble_vec, reg_expr))

        if !isnothing(index) 
            field_dict[field] = index
        else
            error("Missing field $(field) in the file")
        end
    end

    regex_preamble = r"\s*(.*)\s*:\s+([\d\D]*?)(?=(.*:)|$)"
    
    for m in eachmatch(regex_preamble, preamble)
        field = m.captures[1]
        content = m.captures[end-1]

        preamble_dict[field] = strip(content, ['\n', '\r', ' ', '\"'])
    end

    return preamble_dict
end

function process_preamble(preamble::Dict{String, String})
    # checking discount syntax => it must be a float number
    discount = parse(Float64, preamble["discount"])
    if ~(0 <= discount <= 1) 
        error("Discount parameter must be a number between zero and one") 
    end

    # checking value syntax => either "reward" or "cost"
    values_type = preamble["values"]
    values_param = [(isequal(values_type,"reward")) || (isequal(values_type,"cost") || isequal(values_type, "rewards") || isequal(values_type, "costs")) ? values_type : error("Invalid specification for the objective function.")]
    # checking actions syntax => either an integer or a collection of names
    actions_param = convert_to_data_structure("actions", preamble) 
    # checking states syntax => either an integer or a collection of names
    states_param = convert_to_data_structure("states", preamble) 
    # checking observation syntax => either an integer or a collection of names
    observations_param = convert_to_data_structure("observations", preamble)



    return discount, values_param, ContainerNames(actions_param), ContainerNames(states_param), ContainerNames(observations_param)
end

################ Auxiliary functions -- INITIAL DISTRIBUTION ################## 

function _process_initial_distribution_start(state_size::Int64, after_colon::String, name_of_states::Dict{String, Int64})
    aux_var = tryparse(Int64, after_colon)

    if all(map(x -> !isnothing(tryparse(Int64, x)), split(after_colon))) # testing whether is a number
        aux_var = map(x -> parse(Int64, x), split(after_colon))  

        if maximum(aux_var) > state_size
            error("Unable to parse the initial state since initial condition is larger than the size of the state space.")
        end

        value_of_distribution = Diagonal(ones(Float64, state_size))[:,aux_var]
        support_of_distribution = Set{Int64}(aux_var) 

        if length(aux_var) == 1
            return InitialStateParam{Int64}(state_size, "dirac", support_of_distribution, vec(value_of_distribution)) 
        else
            value_of_distribution = sum(value_of_distribution, dims=2) |> vec
            value_of_distribution = value_of_distribution/sum(value_of_distribution)
            return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution) 
        end
        
    elseif all(x -> isa(x, Float64) && (x<=1) && (x>=0) , map(x->tryparse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))) # testing whether initial distirbution is a probability vector
        value_of_distribution =  map(x->parse(Float64, replace(x, r"[\"+]|[\[+]|[\]+]|[\,+]" => "")), split(after_colon))
        support_of_distribution =  Set(findall(x -> x > 0, value_of_distribution))
        return InitialStateParam{Int64}(state_size, "general distribution", support_of_distribution, value_of_distribution) 

    elseif isequal(replace(after_colon, r"[\"+]|[\s+]" => ""), "uniform") # testing initial state is uniform 
        value_of_distribution = (1/state_size)*ones(state_size)
        support_of_distribution = Set{Int64}([i for i in Base.OneTo(state_size)])

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, value_of_distribution)

    elseif all(x -> x in keys(name_of_states), split(after_colon)) # where the initial distribution is passed with names
        init_state = map(x -> name_of_states[x], split(after_colon))

        support_of_distribution = Set{Int64}(init_state)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)
        
        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        error("Invalid syntax for the initial condition.")
    end
end

function _process_initial_distribution_start_include(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})
    init_state = split(after_colon)
    state_size = number(state_initial_param)
    
    if all(x -> tryparse(Int64, x) in 1:state_size, init_state) 
        adding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 

    elseif all(x -> x in keys(name_of_states), init_state)
        init_state = map(x -> name_of_states[x], init_state)
        adding_set = Set{Int64}(init_state)
        
        support_of_distribution = union(adding_set, state_initial_param.support_of_distribution) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

        return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
    else
        error("Unable to parse the start include line.")
    end
end

function _process_initial_distribution_start_exclude(state_initial_param::InitialStateParam, after_colon::String, name_of_states::Dict{String, Int64})
    init_state = split(after_colon)
    state_size = state_initial_param.size_of_states
    
    if all(x -> isa(tryparse(Int64, x), Int64), init_state) 
        excluding_set = Set{Int64}(map(x -> parse(Int64, x), init_state)) 

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set)
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    elseif all(x -> x in keys(name_of_states), init_state)
        init_state = map(x -> name_of_states[x], init_state)
        excluding_set = Set{Int64}(init_state)

        support_of_distribution = setdiff(state_initial_param.support_of_distribution, excluding_set) 
        value_of_distribution = (1/length(support_of_distribution))*sum(Diagonal(ones(state_size))[:,collect(support_of_distribution)], dims=2)

    else
        error("Unable to parse the start exclude line.")
    end
    
    return InitialStateParam{Int64}(state_size, "uniform", support_of_distribution, vec(value_of_distribution)) 
end

function process_initial_distribution(number_of_states::Int64, name_of_states::Dict{String, Int64}, initial_state_ocurrences::Vector{String})
    # According to the grammar this can either be a number, a probability distribution over states, or strings (uniform or states' names)
    initial_state_param = InitialStateParam(number_of_states)
    
    for line in initial_state_ocurrences
        type_init_state = get_before_colon(line)
        param_init = get_after_colon(line) 
       
        if isequal(type_init_state, "start")
            initial_state_param = _process_initial_distribution_start(number_of_states, param_init, name_of_states)

        elseif isequal(type_init_state, "start include")
            initial_state_param = _process_initial_distribution_start_include(initial_state_param, param_init, name_of_states)
            
        elseif isequal(type_init_state, "start exclude")
            initial_state_param = _process_initial_distribution_start_exclude(initial_state_param, param_init, name_of_states)
        else
            error("Unable to parse the initial condition.")
        end
    end

    return initial_state_param
end